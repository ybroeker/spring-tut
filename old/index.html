<!DOCTYPE html>
<html lang="de">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
        <meta charset='utf-8'/>
        <link rel="stylesheet" href="css/bootstrap.css">
        <link rel="stylesheet" href="css/bootstrap-theme.css">
        <link rel="stylesheet" href="css/highlight/idea.css">
        <script src="js/jquery.js"></script>
        <script src="js/bootstrap.js"></script>
        <script src="js/highlight.pack.js"></script>
        <style>
            pre {
                padding: 0;
                font-family: monospace;
                background-color: #f1f1ff;
            }

            body {
                background-color: #eeeeee;
                font-family: Helvetica;
                text-align: justify;
            }

            hr {
                margin-top: 50px;
                margin-bottom: 50px;
                border-color: #85858d;
            }

            .container {
                background-color: white;
                border-radius: 15px;
            }

            .jumbotron > .container {
                background-color: transparent;
            }
        </style>
        <script>
            $(function () {
                $('pre code').each(function (i, block) {
                    hljs.highlightBlock(block);
                });
                var highlightInline = function (cssClass, language) {
                    $("." + cssClass).each(function (i, block) {
                        var jqBlock = $(block);
                        var result = hljs.highlight(language, jqBlock.text());
                        if (result.r) {
                            jqBlock.html(result.value);
                        }
                    });
                };
                highlightInline("code-java", "java");
                highlightInline("code-html", "html");
            });
        </script>
        <title>Spring Boot Tutorial - Ein Blog</title>
    </head>
    <body>
        <div class='container'>
            <h1>Spring Boot Tutorial - Ein Blog</h1>


            <div>

                <!--Einleitung-->
                <div>

                    <div class="well">
                        <h2>Ziel</h2>

                        <p>Ziel dieses Tutorials ist es, Entwicklern mit wenig oder gar keiner Erfahrung in der Entwicklung von
                            Webanwendungen
                            einen ersten Einblick in die Entwicklung mit Spring zu verschaffen. </p>

                        <p>Hierfür wird auf Basis eines der Standard-Archetypes von Spring Boot ein Projekt aufgesetzt, das im Laufe
                            einiger
                            Schritte zu einem Funktionsfähigen (wenn auch rudimentären) Blog entwickelt wird.</p>
                    </div>


                    <p>Folgende Werkzeuge, Frameworks und sonstige Technologien sind dazu eingeplant:<br/>
                    <table class="table table-condensed">
                        <tr class="row">
                            <td><a href="http://maven.apache.org/">maven</a></td>
                            <td>Build-Tool.<br/><b>Alternative:</b> <a href="https://gradle.org/">Gradle</a></td>
                        </tr>
                        <tr class="row">
                            <td><a href="http://spring.io/">spring</a></td>
                            <td>Framework für Dependency-Injection. Hier alternativlos!</td>
                        </tr>
                        <tr class="row">
                            <td><a href="http://www.h2database.com/">H2</a></td>
                            <td>Embedded-Datenbank.<br/><b>Alternativen:</b> <a href="http://db.apache.org/derby/">Derby</a>, <a
                                    href="http://sqlite.org/">SQLite</a> (z.B. mit <a href="https://bitbucket.org/xerial/sqlite-jdbc">Xerial</a>)
                            </td>
                        </tr>
                        <tr class="row">
                            <td><a href="http://www.thymeleaf.org/">Thymeleaf</a></td>
                            <td>Template-Sprache<br/><b>Alternativen:</b> <a href="http://www.oracle.com/technetwork/java/javaee/jsp/index.html">JSP</a>, <a
                                    href="https://velocity.apache.org/">Velocity</a>, <a href="http://freemarker.org/">Freemarker</a>
                            </td>
                        </tr>
                    </table>
                    <hr>
                </div>


                <!--Nav-->
                <div>


                    <ul>
                        <li><a href="#create">Schritt 1 - Erzeugen des Projektes</a></li>
                        <li><a href="#understand">Schritt 2 - Erzeugten Code verstehen</a></li>
                        <li><a href="#domain_model">Schritt 3 - Domänenmodell erstellen</a></li>
                        <li><a href="#view">Schritt 4 - View erstellen</a></li>
                        <li><a href="#controller">Schritt 5 - Controller erstellen</a></li>
                        <li><a href="#bugfixing">Schritt 6 - Ausprobieren und Fehler beseitigen</a></li>                        
                        <li><a href="#services">Schritt 7 - Services erstellen und anbinden</a></li>
                        <li><a href="#db">Schritt 8 - Datenbank erstellen</a></li>
                        <li><a href="#db2">Schritt 9 - Datenbank anbinden</a></li>
                        <li><a href="#add">Schritt 10 - BlogPosts hinzufügen</a></li>
                        <li><a href="#login">Schritt 11 - Login und Authentifizierung</a></li>
                        <li><a href="#user_db">Schritt 12 - Benutzerverwaltung in der Datenbank</a></li>
                        <li><a href="#authors">Schritt 13 - Autor in Blogeinträgen hinterlegen</a></li>
                        <li><a href="#db3">Schritt 14 - Datenbank zwischen Programmstarts beibehalten</a></li>
                        <li><a href="#validation">Schritt 15 - Form Validation</a></li>
                        <li><a href="#search">Schritt 16 - Nach Autor suchen</a></li>
                        <li><a href="#next">Weitere Schritte</a></li>
                        <li><a href="#links">interessante Links und weitere Literatur</a></li>
                        <li><a href="#notes">weitere Hinweise</a></li>
                    </ul>
                    <hr>
                </div>



                <!--Schritt 1 - Projekt erstellen-->
                <div id="create">
                    <div class="well">


                        <h2>Schritt 1 - Erzeugen des Projektes</h2>

                        <div>

                            <p>Das Erzeugen eins Projekts nehmen wir euch an dieser Stelle ab. Wer nachlesen möchte, wie man ein
                                einfaches Spring Boot Projekt mit Thymeleaf aufsetzen kann, findet
                                <a href="https://spring.io/guides/gs/serving-web-content/">hier</a> weitere Informationen.
                                Für uns reicht es, dass Repo des Sommersemester 2016 Projekts zu clonen und auf den korrekten Branch
                                zu wechseln:</p>
                            <pre>
<code class="bash">git clone https://tdpe.techfak.uni-bielefeld.de/git/tdpe-ss-2016
cd tdpe-ss-2016
git checkout thymeleafstarter</code></pre>

                            <p>Wie das hier generierte Projekt im Detail aussieht, sehen wir uns im nächsten Schritt an. Vorher probieren
                                wir
                                aber noch aus, was das neue Projekt schon kann:</p>
                            <pre><code class="bash">mvn spring-boot:run</code></pre>

                        </div>

                        <p>
                            Die Ausgabe auf der Konsole sollte, nach den üblichen Meldungen die Anzeigen das Maven das Projekt baut, in etwa
                            so aussehen:
                        </p>


                        <pre><code>  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v1.3.3.RELEASE)

2016-04-03 11:48:10.869  INFO 23424 --- [           main] d.u.t.t.t.SampleWebJspApplication        : Starting SampleWebJspApplication on YBMacBook.local with PID 23424 (/Users/yannick-broeker/Documents/SHK/1616/tyhemleafloesung/tdpe-tut-sommer-2016/target/classes started by yannick-broeker in /Users/yannick-broeker/Documents/SHK/1616/tyhemleafloesung/tdpe-tut-sommer-2016)
2016-04-03 11:48:10.875  INFO 23424 --- [           main] d.u.t.t.t.SampleWebJspApplication        : No active profile set, falling back to default profiles: default
2016-04-03 11:48:11.499  INFO 23424 --- [           main] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@3ea4c2e9: startup date [Sun Apr 03 11:48:11 CEST 2016]; root of context hierarchy
2016-04-03 11:48:12.282  INFO 23424 --- [           main] o.s.b.f.s.DefaultListableBeanFactory     : Overriding bean definition for bean 'beanNameViewResolver' with a different definition: replacing [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration; factoryMethodName=beanNameViewResolver; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [org/springframework/boot/autoconfigure/web/ErrorMvcAutoConfiguration$WhitelabelErrorViewConfiguration.class]] with [Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter; factoryMethodName=beanNameViewResolver; initMethodName=null; destroyMethodName=(inferred); defined in class path resource [org/springframework/boot/autoconfigure/web/WebMvcAutoConfiguration$WebMvcAutoConfigurationAdapter.class]]
2016-04-03 11:48:13.208  INFO 23424 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)
2016-04-03 11:48:13.229  INFO 23424 --- [           main] o.apache.catalina.core.StandardService   : Starting service Tomcat
2016-04-03 11:48:13.236  INFO 23424 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.0.32
2016-04-03 11:48:13.389  INFO 23424 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2016-04-03 11:48:13.390  INFO 23424 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1892 ms
2016-04-03 11:48:13.766  INFO 23424 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]
2016-04-03 11:48:13.772  INFO 23424 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'characterEncodingFilter' to: [/*]
2016-04-03 11:48:13.773  INFO 23424 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]
2016-04-03 11:48:13.773  INFO 23424 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'httpPutFormContentFilter' to: [/*]
2016-04-03 11:48:13.773  INFO 23424 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'requestContextFilter' to: [/*]
2016-04-03 11:48:14.212  INFO 23424 --- [           main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@3ea4c2e9: startup date [Sun Apr 03 11:48:11 CEST 2016]; root of context hierarchy
2016-04-03 11:48:14.356  INFO 23424 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/]}" onto public java.lang.String de.unibielefeld.techfak.tdpe.thymeleaf.WelcomeController.welcome(java.util.Map&lt;java.lang.String, java.lang.Object&gt;)
2016-04-03 11:48:14.358  INFO 23424 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error]}" onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)
2016-04-03 11:48:14.358  INFO 23424 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/error],produces=[text/html]}" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
2016-04-03 11:48:14.387  INFO 23424 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2016-04-03 11:48:14.387  INFO 23424 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2016-04-03 11:48:14.490  INFO 23424 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]
2016-04-03 11:48:15.074  INFO 23424 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
<b>2016-04-03 11:48:15.198  INFO 23424 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)</b>
2016-04-03 11:48:15.204  INFO 23424 --- [           main] d.u.t.t.t.SampleWebJspApplication        : Started SampleWebJspApplication in 4.94 seconds (JVM running for 11.305)
2016-04-03 11:48:51.563  INFO 23424 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2016-04-03 11:48:51.563  INFO 23424 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2016-04-03 11:48:51.579  INFO 23424 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 16 ms

</code></pre>


                        <p>Besonders wichtig ist hier der fett markierte Teil - Die Anwendung hat automatisch einen Tomcat gestartet und
                            ist
                            nun auf <a target="_blank" href="http://localhost:8080">http://localhost:8080</a> erreichbar.</p>

                        <p>Ruft man die Webapplikation nun im Browser auf, sollte sich in etwa folgendes Bild zeigen:</p>
                        <img src="img/step1-webapp.png" class="center-block" />
                    </div>
                    <hr>
                </div>
                <!--Schritt 2 - Code verstehen-->
                <div id="understand">
                    <div class="well">
                        <h2>Schritt 2 - Erzeugten Code verstehen</h2>

                        <h3><code>SampleWebJspApplication.java</code></h3>
                        Das Projekt enthält zwei Java-Klassen: Die erste die wir uns ansehen wollen ist <code>SampleWebJspApplication</code> und
                        sollte
                        wie folgt aussehen:
                        <pre><code class="java">@Configuration
@EnableAutoConfiguration
@ComponentScan
public class SampleWebJspApplication extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(SampleWebJspApplication.class);
    }

    public static void main(String[] args) throws Exception {
        SpringApplication.run(SampleWebJspApplication.class, args);
    }

}</code></pre>
                        <p>Diese Klasse kümmert sich generell um den Programmstart, bzw. weist - je nachdem wie die Anwendung gestartet
                            wurde - auf passende
                            Art Spring an, die notwendige Initialisierung und Konfiguration durchzuführen.</p>

                        <h4>Zunächst die Annotationen an der Klasse:</h4>

                        <dl>
                            <dt>
                            <div class="code-java">@Configuration</div>
                            </dt>
                            <dd>Diese Klasse enthält Informationen die zur Konfiguration der Anwendung beim Programmstart notwendig sind
                            </dd>
                            <dt>
                            <div class="code-java">@EnableAutoConfiguration</div>
                            </dt>
                            <dd>Weist Spring Boot an, für diverse Konfigurationen (z.B. Template-Pfade, Datenbankverbindung) falls nötig
                                Standardwerte anzunehmen
                            </dd>
                            <dt>
                            <div class="code-java">@ComponentScan</div>
                            </dt>
                            <dd>Suche im Classpath nach Klassen die z.B. mit <span class="code-java">@Controller</span> oder <span class="code-java">@Service</span> annotiert sind und mache sie als
                                Beans verfügbar
                            </dd>
                        </dl>

                        <h4>Nun zu den Methoden:</h4>


                        <pre>
<code class="java">@Override
protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
    return application.sources(SampleWebJspApplication.class);
}
</code></pre>
                        <p>
                            <!-- Was ist ein Tomcat? => Glossar, Beschreibung, externer Link -->
                            Dies ist der Einstiegspunkt für die Applikation, wenn sie auf einem separatem Tomcat deployed wurde. Ein Tomcat ist
                            ein Open-Source-Webserver, der es erlaubt in Java geschriebene Anwendungen auf Servlet- oder JSP-Basis auszuführen.
                            (Weitere Informationen findet man bei <a href="https://de.wikipedia.org/wiki/Apache_Tomcat">Wikipedia</a> und auf der
                            <a href="http://tomcat.apache.org/">Homepage</a> des Projekts)
                            Ähnlich zur Verwendung von <span class="code-java">SpringApplication.run()</span> in der unten erklärten main-Methode wird hier Spring Boot
                            darüber Informiert, wo es anfangen soll nach Konfiguration zu suchen.
                        </p>

                        <pre>
<code class="java">public static void main(String[] args) throws Exception {
    SpringApplication.run(SampleWebJspApplication.class, args);
}</code></pre>
                        <p>
                            Dies ist der Einstiegspunkt für die Applikation, wenn sie als .jar gebaut wurde.
                            SpringApplication.run() erwartet als Parameter einen oder mehrere Quellen von Konfigurationsdaten - z.B.
                            mit <span class="code-java">@Configuration</span> annotierte Klassen.
                        </p>

                        <h3><code>WelcomeController.java</code></h3>
                        <pre><code class="java">@Controller
public class WelcomeController {

    @Value(&quot;${application.message:Hello World}&quot;)
    private String message = &quot;Hello World&quot;;

    @RequestMapping(&quot;/&quot;)
    public String welcome(Map&lt;String, Object&gt; model) {
        model.put(&quot;time&quot;, new Date());
        model.put(&quot;message&quot;, this.message);
        return &quot;welcome&quot;;
    }

}</code></pre>
                        <p>
                            Diese Klasse ist (wie die Annotation und der Name bereits andeuten...) ein Controller. Controller in einer
                            Spring
                            WebMVC-Anwendung
                            nehmen HTTP-Anfragen entgegen, erzeugen ein geeignetes Model und benennen die zu verwendende View. Sie
                            bieten
                            den Startpunkt, von dem aus
                            Aktionen des Benutzers verarbeitet werden.
                        </p>


                        <pre>
<code class="java">    @RequestMapping(&quot;/&quot;)
    public String welcome(Map&lt;String, Object&gt; model) {
        model.put(&quot;time&quot;, new Date());
        model.put(&quot;message&quot;, this.message);
        return &quot;welcome&quot;;
    }
</code></pre>
                        <p>
                            Das <span class="code-java">@RequestMapping("/")</span> deutet an, dass diese Methode aufgerufen werden soll wenn eine HTTP-Anfrage auf
                            den Pfad "/" stattfindet. <br/>
                            Die Methode gibt den Namen einer View zurück, die für die Antwort an den Browser dargestellt werden soll. Der
                            zurückgelieferte Viewname "welcome" wird in dieser Anwendung
                            letztendlich auf <code>src/main/resources/templates/welcome.html</code> abgebildet.<br/>
                            <!-- wie funktioniert das letztendlich? -->
                            Das als parameter übergebene Model (hier vom typ <code>java.util.Map</code>, in der Regel eher vom Typ
                            <code>org.springframework.ui.Model</code>) wird mit Daten befüllt, die in der View angezeigt werden sollen.
                        </p>


                        <pre><code class="java">    @Value("${application.message:Hello World}")
    private String message = "Hello World";
</code></pre>
                        <p>
                            Die Initialisierung von message mit <span class="code-java">= "Hello World"</span> hat hier keine Bedeutung und kann auch weg gelassen
                            werden.
                            <br/>
                            Spannend ist vor allem die Annotation: Mit <span class="code-java">@Value("${application.message}")</span> wird Spring angewiesen, diese
                            Variable mit einem Wert aus der Datei <code>application.properties</code> vorzubelegen, der unter dem Schlüssel <i>application.message</i>
                            zu finden ist. <br/>
                            Durch das hinzufügen von <span class="code-java">":Hello World"</span> in der Annotation wird <span class="code-java">"Hello World"</span> als Standardbelegung angenommen,
                            falls
                            der gesuchte Schlüssel in den <code>application.properties</code> nicht gefunden wurde. <br/>
                            Würde die Standardbelegung im <span class="code-java">@Value</span> weggelassen, gäbe es statt dessen beim Anwendungsstart eine Exception wenn
                            die
                            entsprechende Property fehlt.
                        </p>

                        <h3><code>application.properties</code></h3>
                        <p>
                            Die Datei <code>application.properties</code> findet man unter <code>src/main/resources</code>.
                            <!-- Wo liegt die Datei? -->
                        <pre><code>     application.message: Hello Phil
</code></pre>
                        <p>
                            Diese Zeile liefert die Belegung für das per <span class="code-java">@Value()</span> befüllte Feld von
                            <code>WelcomeController</code>.
                        </p>

                        <h3>View</h3>
                        <p>
                            Das einzige Template (auch View genannt) findet sich unter <code>src/main/resources/templates</code> und heißt <code>welcome.html</code>.
                        <pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th="http://www.thymeleaf.org"&gt;
&lt;head&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p th:text="${message} + '!' " /&gt;
&lt;p th:text="'Current time: ' + ${time}"/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
                        <p>
                            Im Kern handelt es sich bei der Datei um eine HTML-Datei, mit einigen Erweiterungen. Dementsprechend
                            hat sie die übliche Struktur eines HTML Dokuments mit einem HTML5 Doctype. Ein Vorteil von Thymeleaf
                            ist an dieser Stelle, dass diese Datei auch ohne das Auflösen von Variablen oder Tags im Browser
                            anzeigbar ist.
                        </p>

                        <p>
                            Dieses Template zeigt vor allem, wie man auf Variablen zugreift, die entweder im Controller ins Model 
                            eingefügt worden sind, oder innerhalb der Template definiert wurden: Dazu schreibt man <span class="code-html">${variablenname}</span>. 
                            Handelt es sich bei der Variablen nicht um einen String (z.B. <code>time</code>, was im Controller als ein 
                            <span class="code-java">java.util.Date</span> erzeugt wurde), wird sie zur Ausgabe mittels ihrer <span class="code-java">toString()</span>-Methode formatiert. 
                        </p>

                    </div>

                    <hr>
                    <div class="jumbotron">
                        <div class="container">
                            <h2>Zusammenfassung</h3>
                                <ul>
                                    <li>Die Anwendung verwendet generell die Standardeinstellungen die von Spring Boot vorgeschlagen werden
                                    </li>
                                    <li>Bei Anfragen auf dem Pfad / wird die Datei <code>welcome.html</code> mit einem Datum und einer Nachricht versorgt und
                                        gerendert
                                    </li>
                                    <li>Konfigurationsdaten liegen in <code>application.properties</code></li>
                                    <li>Als Templatesprache wird Thymeleaf verwendet. Die Beispielseite zeigt, wie man einfachen Text ausgibt und 
                                        Daten vom Java-Teil eurer Anwendung (das sogenannte Backend) in den HTML-Teil eurer Anwendung (das 
                                        sogenannte Frontend) transferiert.
                                    </li>
                                </ul>
                        </div>
                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>

                <!--Schritt 3 - Domänenmodell-->
                <div id="domain_model">
                    <div class="well">
                        <h2>Schritt 3 - Domänenmodell erstellen</h2>

                        <p>
                            Erster Schritt beim Erstellen des Blogs ist das Erstellen des Domänenmodells - dem Datenmodell, mit dem später gearbeitet wird.
                            Für den Blog sind dies (erstmal) die einzelnen Blogeinträge, welche eine Titel und einen Text, jeweils Strings, haben sollen.
                            Um später einzelne Blogeinträge ansprechen zu können, brauchen diese zusätzlich noch eine ID. Diese ist, um möglichst variabel zu sein, auch ein String.
                        </p>

                        <p>Im Package <code>de.unibielefeld.techfak.tdpe.thymeleaf.domain</code> (muss erst noch erstellt werden!) wird dazu die 
                            Klasse <code>BlogPost</code> erstellt:</p>

                        <pre><code class="java">public class BlogPost {
    private final String id;
    private final String title;
    private final String text;

    public BlogPost(String id, String title, String text) {
        this.id = id;
        this.title = title;
        this.text = text;
    }

    //... hier bitte getter für alle Felder einfügen. (Keine Setter - die Felder sind final!)
}
</code></pre>


                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>

                <!--Schritt 4 - View-->
                <div id="view">
                    <div class="well">
                        <h2>Schritt 4 - View erstellen</h2>

                        <p>
                            Um die BlogPosts anzeigen zu können, wird eine passende View benötigt.
                            Dazu wird in <code>src/resources/templates</code> die Datei index.html erstellt:
                        </p>

                        <pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th="http://www.thymeleaf.org"&gt;

&lt;body&gt;

&lt;h1&gt;BlogPosts&lt;/h1&gt;
&lt;div&gt;
    &lt;table&gt;
        &lt;tr th:each="post:${blogPosts}"&gt;
            &lt;h2 th:text="${post.title}"/&gt;
            &lt;p th:text="${post.text}"/&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>

                        <p>
                            Diese ist ähnlich aufgebaut wie die welcome.html aus Schritt 2, enthält jedoch zusätzlich die Verwendung
                            einer for-each-Schleife aus Thymeleaf. Genauer wird hier über den &lt;table&gt;-Tag verkündet, dass eine 
                            Tabelle erstellt werden soll. Spalten der Tabelle starten jeweils mit einem &lt;tr&gt;-Tag in dem wir 
                            zusätzlich mittels Thymeleaf (th:each) eine Schleife eingebaut haben. Wir wollen hier über blogPosts 
                            iterieren, die uns später der Controller liefern wird. Einzelne Posts können wir dann innerhalb der
                            Tabellenspalte mit <i>post</i> ansprechen und uns auch Titel und Inhalt holen und anzeigen lassen.
                            Durch die Verwendung von for-each wird also für alle in blogPosts vorhandenen Posts eine Tabellenspalte
                            mit Titel und Inhalt angelegt.
                        </p>
                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>


                <!--Schritt 5 - Controller-->
                <div id="controller">
                    <div class="well">
                        <h2>Schritt 5 - Controller erstellen</h2>

                        <p>
                            Damit die eben erstellte View angezeigt werden kann, muss noch eine Controller erstellt werden, 
                            der BlogPosts zum anzeigen bereitstellt und die anzuzeigende View angibt.
                        </p>

                        <p>
                            Dazu wird in <code>de.unibielefeld.techfak.tdpe.thymeleaf</code> die Klasse <code>BlogController</code> erstellt:
                        </p>

                        <pre><code class="java">import de.unibielefeld.techfak.tdpe.thymeleaf.domain.BlogPost;
import java.util.LinkedList;
import java.util.List;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class BlogController {

    @RequestMapping("/")
    public String index(Model model) {
        model.addAttribute("blogPosts", this.getBlogPosts());
        return "index";
    }

    private List&lt;BlogPost&gt; getBlogPosts() {
        BlogPost blogPost = new BlogPost("1", "erster BlogPost", "Mein erster Blogpost.");

        List&lt;BlogPost&gt; blogPosts = new LinkedList&lt;BlogPost&gt;();
        blogPosts.add(blogPost);

        return blogPosts;
    }
}
</code></pre>

                        <p>
                            Damit in der View auch BlogPosts angezeigt werden, 
                            wird in getBlogPosts() vorläufig eine feste Liste von BlogPosts erstellt.
                            Später stehen diese natürlich nicht mehr im Programm, sondern werden z.B. aus einer Datenbank geladen, 
                            vorläufig reicht uns dies aber, um zu testen, ob unser Contoller überhaupt funktioniert.
                        </p>

                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>
                
                

                <!--Schritt 6 -Fehler beseitigen & testen-->
                <div id="bugfixing">

                    <div class="well">
                        <h2>Schritt 6 - Ausprobieren und Fehler beseitigen</h2>

                        <p>
                            Mit <code class="bash">mvn spring-boot:run</code> kann man das Priojekt jetzt bauen und starten.
                            Versucht man dies, startet Spring zwar, bricht dann jedoch mit einer langen Fehlermelung ab:
                        </p>
                        <p>(der Stacktrace wurde etwas gekürzt)</p>

                        <!-- Hinweis darauf, dass der Stacktrace gekürzt wurde [mind. ein Caused By fehlt]-->
                        <pre><code class="bash">[WARNING] 
java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.springframework.boot.maven.RunMojo$LaunchRunner.run(RunMojo.java:300)
	at java.lang.Thread.run(Thread.java:745)
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'requestMappingHandlerMapping' defined in class path resource [org/springframework/web/servlet/config/annotation/DelegatingWebMvcConfiguration.class]: Invocation of init method failed; nested exception is java.lang.IllegalStateException: Ambiguous mapping found. Cannot map 'welcomeController' bean method 
public java.lang.String de.unibielefeld.techfak.tdpe.thymeleaf.WelcomeController.welcome(java.util.Map&lt;java.lang.String, java.lang.Object&gt;)
to {[/],methods=[],params=[],headers=[],consumes=[],produces=[],custom=[]}: There is already 'blogController' bean method
public java.lang.String de.unibielefeld.techfak.tdpe.thymeleaf.BlogController.index(org.springframework.ui.Model) mapped.
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1553)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:539)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:703)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)
	at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:120)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:648)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:311)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:909)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:898)
	at de.unibielefeld.techfak.tdpe.thymeleaf.SampleWebJspApplication.main(SampleWebJspApplication.java:37)
	... 6 more
Caused by: java.lang.IllegalStateException: Ambiguous mapping found. Cannot map 'welcomeController' bean method 
public java.lang.String de.unibielefeld.techfak.tdpe.thymeleaf.WelcomeController.welcome(java.util.Map&lt;java.lang.String, java.lang.Object&gt;)
to {[/],methods=[],params=[],headers=[],consumes=[],produces=[],custom=[]}: There is already 'blogController' bean method
public java.lang.String de.unibielefeld.techfak.tdpe.thymeleaf.BlogController.index(org.springframework.ui.Model) mapped.
	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.registerHandlerMethod(AbstractHandlerMethodMapping.java:192)
	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.detectHandlerMethods(AbstractHandlerMethodMapping.java:164)
	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.initHandlerMethods(AbstractHandlerMethodMapping.java:124)
	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.afterPropertiesSet(AbstractHandlerMethodMapping.java:103)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.afterPropertiesSet(RequestMappingHandlerMapping.java:126)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1612)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1549)
	... 21 more
</code></pre>

                        <p>
                            Lässt man sich dabei nicht von den sehr kryptischen Fehlermeldungen und Klassennamen abschrecken, 
                            entdeckt man als Grund:
                        </p>
                        <pre><code>Caused by: java.lang.IllegalStateException: Ambiguous mapping found. Cannot map 'welcomeController' bean method 
public java.lang.String de.unibielefeld.techfak.tdpe.thymeleaf.WelcomeController.welcome(java.util.Map&lt;java.lang.String, java.lang.Object&gt;)
to {[/],methods=[],params=[],headers=[],consumes=[],produces=[],custom=[]}: There is already 'blogController' bean method
public java.lang.String de.unibielefeld.techfak.tdpe.thymeleaf.BlogController.index(org.springframework.ui.Model) mapped.
</code></pre>


                        <p>
                            Schaut man sich beiden angemerkten Methodendefinitionen genauer an, sieht man, 
                            dass beide jeweils mit <code>@RequestMapping("/")</code> auf den 
                            "/"-Pfad der Webanwendung reagieren sollen - Spring weiß also nicht, welche Methode es benutzen soll.
                        </p>

                        <p>
                            Um den Fehler zu beheben, darf nur noch eine Methode auf "/" reagieren, 
                            in diesem Fall soll das BlogController.index(Model model) sein.
                            Den WelcomeController brauchen wir dagegen gar nicht mehr 
                            - er liefert eine Seite aus, die wir für den Blog nicht mehr brauchen - 
                            wir können ihn also löschen.
                        </p>

                        <p>
                            Starten wir die Anwendung nun erneut mit <code class="bash">mvn spring-boot:run</code>, startete Spring ohne Probleme.
                            Unter <a target="_blank" href="http://localhost:8080">http://localhost:8080</a> kann man nun den in BlogController erstellten BlogPost sehen.
                        </p>

                        <div class="row">
                            <div class="col-sm-6 col-sm-offset-3">
                                <img src="img/schritt_6.png" alt="Schritt_6" class="center-block img-responsive"/> 
                            </div>
                        </div>

                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>

                <!--Schritt 7 - Services-->
                <div id="services">
                    <div class="well">
                        <h2>Schritt 7 - Services erstellen und anbinden</h2>

                        <p>
                            Damit BlogPosts nicht mehr im Controller direkt erstellt werden müssen, 
                            muss ein Service erstellt werden, welcher diese liefert.
                            In Spring sind Services eine Gruppe von Objekten, welche innerhalb der Anwendung Daten und Funktionen jeglicher Form bereitstellen, 
                            z.B. das Laden von Daten aus einer Datenbank.
                        </p>

                        <p class="h3">Interface</p>

                        <p>
                            Um einen Service zum Liefern der BlogPosts zu erstellen, wird als erstes 
                            im Package <code>de.unibielefeld.techfak.tdpe.thymeleaf.domain</code> das Interface <code>BlogService</code> erstellt:
                        </p>

                        <pre><code class="java">import java.util.List;

public interface BlogService {
    List&lt;BlogPost&gt; getAllPosts();
}</code></pre>

                        <p>
                            Dieses stellt uns eine Methode bereit, die alle BlogPosts zurückgibt.
                        </p>

                        <hr>

                        <p class="h3">Implementation</p>

                        <p>
                            Für dieses Interface brauchen wir zusätzlich auch eine Implementation.
                            Dazu wird wieder im Package <code>de.unibielefeld.techfak.tdpe.thymeleaf.domain</code> die Klasse <code>BlogServiceStub</code> erstellt:
                        </p>
                        <pre><code class="java">import java.util.LinkedList;
import java.util.List;
import org.springframework.stereotype.Service;

@Service
public class BlogServiceStub implements BlogService {

    @Override
    public List&lt;BlogPost&gt; getAllPosts() {
        List&lt;BlogPost&gt; blogPosts = new LinkedList<>();
        
        blogPosts.add(new BlogPost("1", "erster BlogPost", "Mein erster Blogpost."));
        blogPosts.add(new BlogPost("2", "zweiter BlogPost", "Mein zweiter Blogpost."));
        
        return blogPosts;
    }
}
</code></pre>

                        <p>
                            Diese Klasse ist mit <span class="code-java">@Service</span> annotiert. 
                            Dies bedeutet, dass Spring beim Programmstart eine Instanz der Klasse erstellen und global verfügbar machen soll. 
                            Andere Klassen können dann mit Hilfe der <span class="code-java">@Autowired</span>-Annotation darum bitten, 
                            eine Instanz von <code>BlogService</code> in einem privaten Feld oder als Konstruktorparameter zu bekommen, 
                            und werden von Spring mit <code>BlogServiceStub</code> bekannt gemacht.
                        </p>

                        <p>
                            Dieses Konzept nennt sich Dependency Injection und erlaubt es uns, 
                            unsere Services und Controller zu schreiben, ohne uns selbst groß darum kümmern zu müssen, in 
                            welcher Reihenfolge die Klassen an welcher Stelle instanziert werden müssen 
                            und wie sie voneinander abhängen.
                        </p>

                        <p>
                            In der Methode getAllPosts() erstellen wir wieder direkt 2 BlogPosts, wie auch schon im <code>BlogController</code>, 
                            damit wir uns erstmal nicht datum kümmern müssen, wo die BlogPosts letztendlich herkommen.
                        </p>


                        <hr>

                        <p class="h3">Controller anpassen</p>

                        <p>
                            Von der <span class="code-java">@Service</span>-Annotation des <code>BlogServiceStubs</code> machen wir nun im <code>BlogController</code> Gebrauch:
                        </p>

                        <pre><code class="java">import de.unibielefeld.techfak.tdpe.thymeleaf.domain.BlogPost;
import de.unibielefeld.techfak.tdpe.thymeleaf.domain.BlogService;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class BlogController {
    private final BlogService blogService;

    @Autowired
    public BlogController(BlogService blogService) {
        this.blogService = blogService;
    }
        
    @RequestMapping("/")
    public String index(Model model) {
        model.addAttribute("blogPosts", this.getBlogPosts());
        return "index";
    }

    private List&lt;BlogPost&gt; getBlogPosts() {
        return blogService.getAllPosts();
    }
}</code></pre>

                        <p>
                            <code>BlogService blogService</code> ist der BlogService, welcher die BlogPosts liefern soll.
                            Dieses wird über den Konstruktor gesetzt, welcher mit <span class="code-java">@Autowired</span> annotiert ist.
                            Durch diese Annotation erkennt Spring, das es ein passendes Objekt bereitstellen soll. 
                            Dieses Objekt ist jeweils eine Instanz einer mit <span class="code-java">@Service</span> annotierten Klasse, wenn eine Instanz
                            des Interfaces <code>BlogService</code> gebraucht wird, ist dies also die Klasse <code>BlogServiceStub</code>, 
                            welche dieses Interface implementiert und mit <span class="code-java">@Service</span> annotiert ist.
                        </p>

                        <p>
                            Zusätzlich ändern wir die Methode <code>getBlogPosts()</code>, sodass diese nicht mehr selbst BlogPosts erstellt, 
                            sondern diese über den <code>blogService</code> lädt.
                        </p>


                        <hr>

                        <p class="h3">Ausprobieren</p>

                        <p>
                            Die Anwendung kann nun wieder über <code class="bash">mvn spring-boot:run</code> gestartet 
                            und unter <a target="_blank" href="http://localhost:8080">http://localhost:8080</a> erreicht werden.
                        </p>

                        <div class="row">
                            <div class="col-sm-6 col-sm-offset-3">
                                <img src="img/schritt_7.png" alt="Schritt_7" class="center-block img-responsive"/> 
                            </div>
                        </div>

                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>

                <!--Schritt 8 - DB-->
                <div id="db">
                    <div class="well">
                        <h2>Schritt 8 - Datenbank erstellen</h2>

                        <p>
                            Damit die BlogPosts nicht mehr im Code erstellt werden müssen, sollen diese aus einer Datenbank geladen werden. 
                            Für den Datenbankzugriff wird dabei Spring Data verwendet.
                        </p>

                        <p class="h3">Neue Abhängigkeiten</p>

                        <p>
                            Zunächst müssen wir die Bibliotheken, die wir verwenden wollen in die pom.xml unseres Projektes eintragen.
                            Wir
                            benötigen zwei Sachen: Einerseits spring-boot-starter-data-jpa, was die nötigen
                            APIs und ein wenig Standardkonfiguration für den Datenbankzugriff liefert, und andererseits einen geeigneten
                            JDBC-Treiber. Dafür werden wir H2, eine in-memory-Datenbank verwenden. Dies hat den Vorteil, keinerlei
                            Administration oder Installation zu benötigen. Dafür wird allerdings bei jedem Programmstart die Datenbank
                            gelöscht. Um dieses kleinere Problem kümmern wir uns aber erst später.
                        </p>

                        <p>Füge in deine <code>pom.xml</code> folgende Zeilen direkt oberhalb von <code>&lt;/dependencies&gt;</code> ein:</p>
                        <pre><code class="xml">&lt;dependency&gt;
    &lt;groupId>org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId>spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId>com.h2database&lt;/groupId&gt;
    &lt;artifactId>h2&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

                        <p>Nach dem Eintragen in die pom.xml muss diese je nach den Einstellungen der eigenen IDE einmal neu eingelesen werden.
                            Dies lässt sich meistens mit einem Rechtsklick auf die <code>pom.xml</code> und einem entsprechenden 
                            Kontextmenüpunkt machen.
                        </p>

                        <p>
                            spring-boot-starter-data-jpa wird nun, wenn es der Ansicht ist dass wir eine Datenbank brauchen, im Classpath
                            der
                            Anwendung nach einem verwendbaren JDBC-Treiber suchen, den von H2 finden, und darauf basierend
                            eine Standardkonfiguration verwenden.
                        </p>

                        <hr>
                        <p class="h3">Konfiguration</p>

                        <p>
                            Um auf die Datenbank zugreifen zu können, brauchen wir noch etwas Magie von Spring, die wir erstmal explizit
                            erbitten müssen. Dazu füge bei den Annotationen oberhalb der SampleWebJspApplication-Klasse noch folgendes
                            ein:
                        </p>

                        <pre>
<code class="java">@EnableJpaRepositories
@EnableTransactionManagement
</code></pre>
                        <p>
                            Die erste Annotation bringt Spring dazu, beim Programmstart nach bestimmten Interfaces in unserer Applikation
                            zu
                            suchen und automatisch Implementationen davon zu erzeugen.
                            <br/>
                            Die zweite Annotation ist gerade erstmal nicht zwingend notwendig, tut aber auch nicht weh. Sie führt dazu,
                            dass
                            wir Methoden, die mehrere Datenbankzugriffe in einer Transaktion zusammenfassen, einfach mit
                            @Transactional annotieren
                            können, damit Spring sich um das Transaktionsmanagement kümmert.
                        </p>

                        <hr>

                        <p class="h3">Erstellen des Persistenzmodells</p>

                        <p>
                            Wir werden in dieser Anwendung das Persistenzmodell (wie unsere Daten in der Datenbank aussehen) und das
                            Domänenmodell (wie die Daten in der Geschäftslogik modelliert sind) strikt trennen. Das ist in einer so
                            einfachen Anwendung zwar nicht absolut zwingend notwendig, aber in der Regel gute Praxis. 
                            Eine genauere Begründung findet Ihr zum Beispiel in 
                            <a target="_blank" href="http://www.mehdi-khalili.com/orm-anti-patterns-part-4-persistence-domain-model">diesem Blogeintrag.</a>
                        </p>

                        <p>
                            Im Package <code>de.unibielefeld.techfak.tdpe.thymeleaf.persistence</code> (auch das Package muss erstellt werden!) wird dazu die neue Klasse <code>BlogPostEntity</code>
                            erstellt: <!-- Auch hier: Package muss erst erstellt werden! -->
                        </p>
                        <pre><code class="java">import javax.persistence.*;

@Entity(name = "blog_posts")
public class BlogPostEntity {
    @Id
    @GeneratedValue
    @Column(name = "id")
    private Integer id;

    @Column(name = "title")
    private String title;

    @Lob
    @Column(name = "text")
    private String text;

    public BlogPostEntity() {
    }

    public BlogPostEntity(String title, String text) {
        this.title = title;
        this.text = text;
    }

    //... hier bitte Getter und Setter für alle Felder einfügen!
}
</code></pre>
                        <p>
                            Hiermit wird definiert, dass es eine Tabelle mit dem Namen "blog_posts" geben soll, die die Felder "id",
                            "title" und "text" hat und deren Zeilen sich als Objekte der Klasse <code>BlogPostEntity</code> darstellen lassen.
                            <br/>
                            Die Annotation <span class="code-java">@Id</span> zeigt an, dass jede Tabellenzeile durch die Spalte 'id' eindeutig identifizert weden
                            kann.
                            Mit <span class="code-java">@GeneratedValue</span> bitten wir darum, Ids automatisch zuzuweisen damit wir uns nicht darum kümmern müssen.
                            Die
                            Datenbank wird hierzu fortlaufende Nummern vergeben.
                            <br/>
                            Die <span class="code-java">@Column</span>-Annotationen dienen hier vor allem dazu, sicherzustellen dass alle Spalten genau den
                            gewünschten Namen haben. Ohne Angabe eines extra namen wird anhand des Feld-Namens ein Spaltenname generiert.
                            <br/>
                            Mit <span class="code-java">@Lob</span> wird gefordert, dass der Text eines Blogeintrags ein "Large Object" ist.
                            Normalerweise würden Strings durch VARCHAR-Felder dargestellt, die in der Regel nur kurze Strings zulassen (z.B. bis zu 255 Zeichen).
                            Eine <span class="code-java">@Lob</span>-Spalte würde statt dessen als TEXT, LONGTEXT oder etwas ähnlichem dargestellt, was auch lange Texte zulässt.
                        </p>

                        <hr>


                        <p class="h3">Erstellen des Repositories</p>

                        <p>
                            Um Blogeinträge aus der Datenbank zu laden oder zu speichern wird außerdem ein Repository benötigt.
                            Dabei handelt es sich einfach nur um ein Interface das von CrudRepository erbt und beschreibt, was für Objekte mit
                            was für Ids in der Datenbank liegen, und nach welchen Kriterien man diese anfragen kann.<br/>
                            Dazu wird im Package <code>de.unibielefeld.techfak.tdpe.thymeleaf.persistence</code> ein neues Interface <code>BlogPostRepository</code> mit
                            folgendem Inhalt erstellt:
                        </p>
                        <pre>
<code class="java">import org.springframework.data.repository.CrudRepository;

public interface BlogPostRepository extends CrudRepository&lt;BlogPostEntity, Integer&gt;{
}
</code></pre>
                        <p>
                            Jep. Das war alles. Werden keine besonderen Anfragen benötigt, kann man sich mit dem zufrieden geben, was von CrudRepository geerbt wird.
                            Dies sind Methoden zum Erstellen (<b>C</b>reate), Lesen (<b>R</b>ead), Updaten (<b>U</b>pdate) und Löschen (<b>D</b>elete) von Datensätzen.
                            <br>
                            Die Generic-Argumente von CrudRepository erklären Spring, dass
                            wir damit auf BlogPostEntities zugreifen möchten, und dass wir als Ids dabei Integer verwenden. <br/>
                            Eine Implementation von <code>BlogPostRepository</code> brauchen wir nicht zu erstellen - die wird zur Laufzeit von
                            Spring generiert.
                        </p>

                        <hr>

                        <h3>Beispieldaten</h3>

                        <p>Damit beim Testen auch Daten vorhanden sind, wäre es schön wenn die Anwendung beim Start die Datenbank erstmal mit
                            ein paar Beispiel-Blogeinträgen befüllt wird.<br/>
                            Dazu wird eine Datei <code>data.sql</code> im Verzeichnis <code>src/main/resources</code> 
                            (In Netbeans unter "Other Sources" zu finden -- wo bereits die application.properties drin liegt), erstellt:
                        </p>
                        <pre>
<code class="sql">INSERT INTO blog_posts (id, title, text) VALUES (1, 'mein erster eintrag', 'lorem ipsum dolor sit amet...');
INSERT INTO blog_posts (id, title, text) VALUES (2, 'mein zweiter eintrag', 'Wants pawn term, dare worsted ladle gull hoe lift wetter murder inner ladle cordage, honor itch offer lodge dock florist. ');
</code></pre>

                        <hr>

                        <p class="h3">Ausprobieren</p>

                        <p>
                            Die Anwendung kann nun wieder über <code class="bash">mvn spring-boot:run</code> gestartet werden.
                            Auf der Website wird man noch keine Änderungen sehen, jedoch sieht man in den Logs, dass die Datenbank erstellt wurde:
                        </p>
                        <pre><code class="bash">INFO 12182 --- [lication.main()] org.hibernate.Version                    : HHH000412: Hibernate Core {4.3.1.Final}
INFO 12182 --- [lication.main()] org.hibernate.cfg.Environment            : HHH000206: hibernate.properties not found
INFO 12182 --- [lication.main()] org.hibernate.cfg.Environment            : HHH000021: Bytecode provider name : javassist
INFO 12182 --- [lication.main()] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {4.0.4.Final}
INFO 12182 --- [lication.main()] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.H2Dialect
INFO 12182 --- [lication.main()] o.h.h.i.ast.ASTQueryTranslatorFactory    : HHH000397: Using ASTQueryTranslatorFactory
INFO 12182 --- [lication.main()] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000227: Running hbm2ddl schema export
Hibernate: drop table blog_posts if exists
Hibernate: create table blog_posts (id integer generated by default as identity, text clob, title varchar(255), primary key (id))
INFO 12182 --- [lication.main()] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000230: Schema export complete
</code></pre>


                    </div>
                    <hr>
                </div>

                <!--Schritt 9 - DB anbinden-->
                <div id="id2">
                    <div class="well">
                        <h2>Schritt 9 - Datenbank anbinden</h2>

                        <p>
                            Es gibt nun zwar eine Datenbank - die auch schon Einträge enthält - allerdings wird diese noch nicht von der Anwendung benutzt.
                        </p>

                        <p>
                            Um Daten über das Repository aus der Datenbank zu laden, wird wieder ein Service benötigt.
                            <br>
                            Dazu wird im Package <code>de.unibielefeld.techfak.tdpe.thymeleaf.domain</code> die Klasse <code>BlogServiceImpl</code>, 
                            die das Interface <code>BlogService</code> implementiert, erstellt:
                        </p>

                        <pre><code class="java">import de.unibielefeld.techfak.tdpe.thymeleaf.persistence.BlogPostEntity;
import de.unibielefeld.techfak.tdpe.thymeleaf.persistence.BlogPostRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.LinkedList;
import java.util.List;

@Service
public class BlogServiceImpl implements BlogService {
    private final BlogPostRepository blogPostRepository;

    @Autowired
    public BlogServiceImpl(BlogPostRepository blogPostRepository) {
        this.blogPostRepository = blogPostRepository;
    }

    @Override
    public List&lt;BlogPost&gt; getAllPosts() {
        List&lt;BlogPost&gt; result = new LinkedList&lt;BlogPost&gt;();
        for (BlogPostEntity blogPostEntity: blogPostRepository.findAll()) {
            result.add(new BlogPost(
                blogPostEntity.getId().toString(),
                blogPostEntity.getTitle(),
                blogPostEntity.getText()
            ));
        }
        return result;
    }
}</code></pre>

                        <p>
                            BlogServiceImpl ist wieder mit <span class="code-java">@Service</span> annotiert, damit man diese Klasse wieder von Spring 
                            erkannt wird und mit <span class="code-java">@Autowired</span> verfügbar ist.
                            <br>
                            Außerdem ist der Konstruktor mit <span class="code-java">@Autowired</span> annotiert, damit Spring angwiesen wird, 
                            eine Instanz von BlogPostRepository bereitzustellen.
                            <br>
                            In <code>getAllPosts()</code> werden dann alle BlogPostEntitys über das Repository aus der Datenbank geladen, 
                            eine Liste von BlogPosts erstellt, und diese zurückgegeben.
                        </p>

                        <hr>

                        <p class="h3">Ausprobieren</p>

                        <p>
                            Die Anwendung kann nun wieder über <code>mvn spring-boot:run</code> gestartet werden.
                            <br>
                            Spring bricht den Start der Anwendung jedoch wieder mit einer Fehlermeldung ab:
                        </p>

                        <!-- auch hier: Darauf hinweisen, dass der SS gekürzt ist! -->
                        <pre><code class="bash">java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.springframework.boot.maven.RunMojo$LaunchRunner.run(RunMojo.java:300)
	at java.lang.Thread.run(Thread.java:745)
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'blogController' defined in file [/.../blog/target/classes/de/unibielefeld/techfak/tdpe/jsp/BlogController.class]: Unsatisfied dependency expressed through constructor argument with index 0 of type [de.unibielefeld.techfak.tdpe.thymeleaf.domain.BlogService]: : No qualifying bean of type [de.unibielefeld.techfak.tdpe.thymeleaf.domain.BlogService] is defined: expected single matching bean but found 2: blogServiceImpl,blogServiceStub; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [de.unibielefeld.techfak.tdpe.thymeleaf.domain.BlogService] is defined: expected single matching bean but found 2: blogServiceImpl,blogServiceStub
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:747)
	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:185)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1114)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1017)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:504)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:703)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)
	at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:120)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:648)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:311)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:909)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:898)
	at de.unibielefeld.techfak.tdpe.thymeleaf.SampleWebJspApplication.main(SampleWebJspApplication.java:37)
	... 6 more
Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [de.unibielefeld.techfak.tdpe.thymeleaf.domain.BlogService] is defined: expected single matching bean but found 2: blogServiceImpl,blogServiceStub
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:970)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:858)
	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:811)
	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:739)
	... 24 more             
</code></pre>

                        <p>
                            Der Grund für den Fehler lässt sich wieder am unteren Ende des StackTraces finden:
                        </p>

                        <pre><code class="bash">Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [de.unibielefeld.techfak.tdpe.thymeleaf.domain.BlogService] is defined: expected single matching bean but found 2: blogServiceImpl,blogServiceStub
</code></pre>

                        <p>
                            Innerhalb des Projektes sind zwei Klassen, die BlogService implementieren, mit <span class="code-java">@Service</span> annotiert. 
                            Wird nun mit <span class="code-java">@Autowired</span> eine Instanz von BlogService angefordert, weiß Spring nicht, welche der beiden Klassen genutzt werden soll.
                        </p>

                        <p>
                            Um den Fehler zu beheben gibt es drei Möglichkeiten:
                        </p>
                        <ul>

                            <li>Im BlogController keine Instanz von <code>BlogService</code> anfordern, sondern direkt von 
                                <code>BlogServiceImpl</code>-  
                                Dies ist jedoch sehr unschön, da man sich auf feste Implementationen festlegt und
                                späterer Änderungen und Erweiterungen unnötig kompliziert macht
                            </li>
                            <li>
                                Die <span class="code-java">@Service</span>-Annotation von <code>BlogServiceStub</code> entfernen - 
                                Die Klasse wird dann von Spring nicht mehr als Service erkannt, 
                                so kann man jedoch ggf. leicht wieder zur alten Implemenation wechseln.
                            </li>
                            <li>
                                Die Klasse <code>BlogServiceStub</code> löschen - durch Verwendung von git o.ä. kann man, sollte es nötig 
                                sein, die Klasse später wieder herstellen
                            </li>
                            <li>
                                Eine der beiden Services mit <span class="code-java">@Primary</span> annotieren, diese wird 
                                dann bei <span class="code-java">@Autowired</span> bevorzugt
                            </li>

                        </ul>

                        <p>
                            Da BlogServiceStub nicht mehr gebraucht wird, wird es innerhalb dieses Projekts gelöscht.
                        </p>


                        <hr>

                        <p class="h3">Ausprobieren</p>

                        <p>
                            Die Anwendung kann nun wieder über <code class="bash">mvn spring-boot:run</code> gestartet 
                            und unter <a target="_blank" href="http://localhost:8080">http://localhost:8080</a> erreicht werden.
                        </p>

                        <p>
                            Auf der Website sieht man nun die aus der Datenbank geladenen Einträge:
                        </p>

                        <div class="row">
                            <div class="col-sm-6 col-sm-offset-3">
                                <img src="img/schritt_9.png" alt="Schritt_9" class="center-block img-responsive"/> 
                            </div>
                        </div>

                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>

                <!--Schritt 10 - Einträge hinzufügen-->
                <div id="add">
                    <div class="well">
                        <h2>Schritt 10 - BlogPosts hinzufügen</h2>

                        <p>
                            Bisher können nur schon bei Programmstart in der Datenbank hinterlegte BlogPosts angezeigt werden, 
                            es sollen jedoch auch neue Einträge hinzugefügt werden können.
                        </p>

                        <p class="h3">Service anpassen</p>

                        <p>
                            Als Erstes wird dazu <code>BlogService</code> um die Methode 
                            <code>BlogPost createBlogPost(BlogPost blogPost)</code> 
                            erweitert und diese in <code>BlogServiceImpl</code> implementiert:
                        </p>

                        <!-- Klassennamen im Text deutlicher hervorheben! -->
                        <pre><code class="java">@Override
public BlogPost createBlogPost(BlogPost blogPost) {
    BlogPostEntity blogPostEntity = new BlogPostEntity(blogPost.getTitle(), blogPost.getText());
    BlogPostEntity savedEntity = blogPostRepository.save(blogPostEntity);
    
    BlogPost saved = new BlogPost(savedEntity.getId().toString(),savedEntity.getTitle(),savedEntity.getText());
    
    return saved;
}
</code></pre>

                        <p>
                            Diese Methode erzeugt mit den Daten aus dem übergebenen BlogPost die entsprechende BlogPostEntity und speichert diese ab.
                            <br>
                            Aus der zurückgegebenen <code>BlogPostEntity savedEntity</code> wird dann wieder ein BlogPost erstellt, welcher zurückgegeben wird.
                        </p>

                        <hr>

                        <p class="h3">Command Objekt erstellen</p>

                        <p>
                            Für die Formulareingabe später in der View, wird noch ein sogenanntes Command-Objekt benötigt, dass quasi eine Java Entsprechung
                            zu dem HTML Formular darstellt. D.h. für alle Elemente des Formulars (Eingabefelder, Checkboxen etc.) wird ein entsprechendes 
                            Feld in der Java Klasse benötigt. Dieses Objekt sollte sich unter anderem aus Sicherheitsgründen vom Domänen- und Persistenzmodell
                            der Anwendung unterscheiden. Die schon vorhandene Klasse <code>BlogPost</code> fällt somit heraus.
                        </p>
                        <p> Stattdessen wird innerhalb des Packages <code>de.unibielefeld.techfak.tdpe.thymeleaf</code> eine neue Klasse <code>NewBlogPostCmd</code> hinzugefügt:
                        <pre><code class="Java">public class NewBlogPostCmd {

    private String title;
    private String text;

    public NewBlogPostCmd() {

    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
}</code></pre>



                        <hr>

                        <p class="h3">Controller anpassen</p>


                        <p>
                            Der Controller braucht nun zwei neue Methoden - eine um das Formular zum Bearbeiten eines Blogeintrags anzuzeigen, und eine um den neuen Eintrag tatsächlich zu speichern.
                            <br>
                            Dazu wird der <code>BlogController</code> um folgende Methoden erweitert:
                        </p>

                        <pre><code class="java">    @RequestMapping(value = "/new", method = RequestMethod.GET)
    public String showNewPostForm(NewBlogPostCmd newBlogPostCmd) {
        return "newPostForm";
    }

    @RequestMapping(value = "/new", method = RequestMethod.POST)
    public String saveNewPost(NewBlogPostCmd newBlogPostCmd) {
        blogService.createBlogPost(new BlogPost("", newBlogPostCmd.getTitle(), newBlogPostCmd.getText()));
        return "redirect:/";
    }
</code></pre>

                        <p>
                            Die erste Methode tut selber nichts, sondern zeigt einfach die View <code>newPostForm</code> an und unterrichtet mittels des
                            Parameters newBlogPostCmd die View darüber, eine entsprechende Variable vorzuhalten. 
                            <br>
                            Die zweite Methode erhält denselben Parameter, der diesmal allerdings aus den im HTTP-Request übertragenen Formulardaten zu 
                            beziehen ist. In ihm wird also später der Inhalt des HTML-Formulars abgespeichert.
                            <br>
                            Dem aufmerksamen Beobachter mag aufgefallen sein, dass beide Methoden auf Anfragen auf dem 
                            Pfad <span class="code-java">/new</span> reagieren. Das RequestMapping unterscheidet sich nur darin, was als method angegeben ist. 
                            HTTP erlaubt es, beim Zugriff auf eine Seite anzugeben was für eine Art von Zugriff erwünscht ist. 
                            Dies wird im allgemeinen als "method" bezeichnet. Standardmäßig verwendet der Webbrowser immer GET. 
                            Ruft man also einfach nur die URL <span class="code-java">/new</span> auf, wird die methode GET verwendet und showNewPostForm() wird aufgerufen. 
                            In unserem Formular werden wir den Browser anweisen, zum Abspeichern des Blogeintrags statt dessen 
                            POST zu verwenden - dann würde saveNewPost() aufgerufen. 
                            Der HTTP-Standard sieht noch einige weitere Methoden vor, wie z.B. DELETE und PUT, aber die sind für 
                            uns gerade nicht allzu spannend. Solltet Ihr in die Situation kommen, Schnittstellen für AJAX-lastige 
                            Webanwendungen schreiben zu müssen, solltet Ihr euch mit den verschiendenen HTTP-Methoden und ihrer 
                            Bedeutung aber auseinander setzen. 
                            Der von saveNewPost() zurückgelieferte Viewname beginnt mit <code>"redirect:"</code>, um anzudeuten dass wir selber 
                            keine view rendern wollen, sondern der Browser nach Abschluß dieses Requests direkt eine andere URL 
                            aufrufen soll. Die aufzurufende URL ergibt sich aus dem Text hinter dem Doppelpunkt. In diesem Fall 
                            soll also die Startseite (entsprechend der index()-Methode des Controllers) aufgerufen werden.
                        </p>


                        <hr>

                        <p class="h3">View anpassen</p>


                        <p>
                            Um das Formular anzuzeigen, wird noch eine View benötigt.
                            <br>
                            Dazu wird <code>src/main/resources/templates/newPostForm.html</code> erstellt:
                        </p>


                        <pre><code class="html">&lt;!DOCTYPE html&gt;

&lt;html xmlns:th="http://www.thymeleaf.org"&gt;

&lt;body&gt;
&lt;form action="#" th:action="@{/new}" th:object="${newBlogPostCmd}" method="post"&gt;
    &lt;label for="title"&gt;Titel:&lt;/label&gt;
    &lt;input type="text" id="title" name="title" th:field="*{title}"/&gt;
    &lt;label for="text"&gt;Text:&lt;/label&gt;
    &lt;textarea id="text" name="text" th:field="*{text}"&gt;&lt;/textarea&gt;
    &lt;input type="submit" value="Speichern"/&gt;
&lt;/form&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre>

                        <p>
                            Außerdem wird in der index.html noch ein Link auf die neue Seite benötigt, 
                            dazu wird die index.html unter &lt;h1&gt;BlogPosts&lt;/h1&gt; ergänzt um: 
                        </p>


                        <pre><code class="html">&lt;a th:href=&quot;@{/new}&quot;&gt;Neuer Eintrag&lt;/a&gt;
</code></pre>





                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>

                <!--Schritt 11 - Login-->
                <div id="login">
                    <div class="well">
                        <h2>Schritt 11 - Login und Authentifizierung</h2>

                        <p>
                            Bisher ist es für jeden möglich, neue BlogPosts zu erstellen. Besser wäre es jedoch, 
                            wenn jeder Posts lesen kann, aber nur angemeldete Nutzer neue Posts erstellen können.
                        </p>

                        <hr>

                        <p class="h3">
                            Abhängigkeiten
                        </p>

                        <p>
                            Spring liefert bereits ein recht umfassendes Framework um Login, Sessionverwaltung, 
                            und so weiter umzusetzen: Spring Security. 
                            <br>
                            Wie bereits bei der Datenbankanbindung muss man nur in der pom.xml die passende Abhängigkeit angeben -
                            in diesem Fall <code>spring-boot-starter-security</code>.
                        </p>

                        <pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

                        <hr/>

                        <p class="h3">
                            Konfiguration
                        </p>

                        <p>
                            Damit Spring die Benutzerverwaltung passend konfiguriert, braucht man eine Klasse, die die Konfiguration bereitstellt.
                            <br>
                            Dazu wird im neuen Package <code>de.unibielefeld.techfak.tdpe.thymeleaf.config</code> die Klasse <code>SecurityConfig</code> erstellt:
                            <!-- Package muss erstellt werden! -->
                        </p>

                        <!-- Problem: Authority <> Role -->
                        <!-- SecurityContextHolder.getSecurityContext().getAuthentication().getPrincipal() -->
                        <pre>
<code class="java">import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests()
                .antMatchers("/").permitAll()
                .anyRequest().hasAuthority("USER")
                .and()
                .formLogin()
                .permitAll()
                .and()
                .logout()
                .permitAll()
        ;
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth
                .inMemoryAuthentication()
                .withUser("user").password("password").authorities("USER");

    }
}
</code></pre>

                        <p>
                            Die configure()-Methode gibt an, dass:
                        </p>
                        <ul>
                            <li>
                                Anfragen auf <span class="code-java">"/"</span> sollen immer erlaubt sein
                            </li>
                            <li>
                                Alle anderen Anfragen nur für Nutzer mit der Rolle "USER"
                            </li>
                            <li>
                                Ein fertiges Login-Formular von Spring verwendet werden soll und jeder Benutzer Zugriff auf das Formular bekommen soll
                            </li>
                            <li>
                                <!-- Was bedeutet "POST"? --> Es möglich sein soll, durch einen POST-Request auf <span class="code-java">"/logout"</span> sich auszuloggen, und auch das für jeden Benutzer möglich sein soll
                            </li>
                        </ul>
                        <p>
                            In der configureGlobal()-Methode legen wir außerdem fest, dass wir eine feste, im Programm vorgegebene Benutzerliste 
                            haben möchten, nämlich mit den Benutzernamen <span class="code-java">"user"</span> und dem Passwort <span class="code-java">"password"</span>.
                            <br/>
                            Spring Security erlaubt es, Benutzern unterschiedliche Rollen zuzuweisen, 
                            um z.B. zwischen Benutzern und Administratoren zu unterscheiden. 
                            Wir verwenden in dieser Anwendung nur eine Rolle und nennen sie <span class="code-java">"USER"</span>.
                        </p>
                        <hr/>

                        <p class="h3">Ausprobieren</p>
                        <p>
                            Wenn Du die Anwendung nun neu startest, solltest Du beim Klick auf den "Neuer Eintrag"-Link zunächst 
                            im Loginformular landen. Meldest Du dich mit dem Benutzernamen "user" und dem Passwort "password" an, 
                            kannst Du danach wie vorher auch deinen Blogeintrag erstellen.
                        </p>


                        <hr/>

                        <p class="h3">Logout</p>
                        <p>
                            Bisher gibt es für Nutzer keine Möglichkeit, sich wieder auszuloggen.
                            <br/>
                            Wie oben erklärt ist für einen Logout jedoch nur ein POST-Request an "/logout" nötig.
                            <br/>
                            Um dies zu ermöglichen, wird die <code>newPostForm.html</code> unterhalb der <code>&lt;/form&gt;</code>um folgendes erweitert:
                        </p>

                        <pre><code>&lt;form th:action="@{/logout}" method="post"&gt;
    &lt;input type="submit" value="Logout"/&gt;
&lt;/form&gt;
</code></pre>


                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>

                <!--Schritt 12 - Benutzerverwaltung in der Datenbank-->
                <div id="user_db">
                    <div class="well">
                        <h2>Schritt 12 - Benutzerverwaltung in der Datenbank</h2>

                        <p>
                            Die Nutzer sind bisher fest in  <code>SecurityConfig</code> eingetragen, 
                            es lassen sich also keine Nutzer hinzufügen, löschen oder überhaupt bearbeiten.
                            <br>
                            Für einen wirklichen Blog ist es natürlich nötig, das die Nutzer aus ener Datenbank oder ähnlichem geladen werden.
                        </p>

                        <hr>

                        <p class="h3">
                            Domänenmodell
                        </p>

                        <p>
                            Spring Security möchte, dass die Klassen die einen Benutzer darstellen ein bestimmtes 
                            Interface implementieren - UserDetails. Der einfachste Weg dazu ist, von einer von 
                            Spring Security bereitgestellten Klasse <code>User</code> zu erben. 
                            <br/>
                            Dazu wird im package <code>de.unibielefeld.techfak.tdpe.thymeleaf.domain</code> die neue Klasse <code>User</code> erstellt:
                        </p>

                        <pre>
<code class="java">import java.util.Arrays;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

public class User extends org.springframework.security.core.userdetails.User {

    private final String firstName;
    private final String lastName;

    public User(String username, String firstName, String lastName, String password, String role) {
        super(username, password, Arrays.asList(new SimpleGrantedAuthority(role)));
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public String getFullName() {
        return firstName + " " + lastName;
    }

    @Override
    public String toString() {
        return "User{"
                + "super='" + super.toString() + "'"
                + ", firstName='" + firstName + '\''
                + ", lastName='" + lastName + '\''
                + '}';
    }
}

</code></pre>

                        <p>
                            Der Nutzer hat in diesem Fall immer genau eine Rolle, die dem Konstruktor übergebene 
                            Rolle <code>role</code>. Diese zu übergeben ist nicht nötig - man könnte sie auch im Konstruktor 
                            neu erstellen, da der Blog nur eine Art Nutzer kennt - es ermöglicht aber später leichtere 
                            Anpassungen, wenn es verschiedene Rollen geben soll.
                            Eine zusätzliche Alternative, wenn ein Nutzer mehrere Rollen haben kann, wäre den Konstruktor ändern, 
                            sodass er nicht eine einzelne Rolle, sondern eine Liste von Rollen entgegennimmt.
                        </p>

                        <hr/>

                        <p class="h3">
                            Persistenzmodell
                        </p>

                        <p>
                            Damit die Nutzer aus der Datenbank geladen werden können, wird wieder ein Persistenzmodell benötigt.
                            <br/>
                            Dazu wird im package <code>de.unibielefeld.techfak.tdpe.thymeleaf.persistence</code> die neue Klasse <code>UserEntity</code> erstellt:
                        </p>

                        <pre>
<code class="java">import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;

@Entity(name = "users")
public class UserEntity {

    @Id
    @Column(name = "username")
    private String username;

    @Column(name = "password_hash")
    private String passwordHash;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;
    
    @Column(name = "user_role")
    private String userRole;

    //Hier bitte getter und setter für alle Felder einfügen!
}
</code></pre>

                        <p>
                            Die Benutzer sollen anhand eines selbst gewählten Loginnamens eindeutig identifiziert werden, daher ist hier
                            kein
                            @GeneratedValue an der Id notwendig.
                        </p>

                        <p>
                            Das Feld für das Passwort heißt "passwordHash", nicht einfach nur "password". Das hat einen guten
                            Grund:
                            <br/>
                            Die Passwörter werden nicht im Plaintext in der Datenbank gespeichert, sondern es wird eine so genannte
                            Hashfunktion auf das Passwort angewendet und das Ergebnis davon gespeichert. Dadurch kann selbst jemand, der Zugang zur
                            Datenbank hat, die Passwörter der Benutzer nicht auslesen, man kann aber trotzdem noch prüfen, ob eine
                            Eingabe gleich dem Passwort des Benutzers ist.
                        </p>

                        <p class="h3">
                            Repository
                        </p>

                        <p>
                            Um Nutzer aus der Datenbank zu laden, ist zusätzlich wieder ein Repository nötig.
                            <br/>
                            Dazu wird im package <code>de.unibielefeld.techfak.tdpe.thymeleaf.persistence</code> das Interface <code>UserRepository</code> erstellt:
                        </p>

                        <pre>
<code class="java">import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends CrudRepository&lt;UserEntity, String&gt; {
}
</code></pre>


                        <hr/>


                        <p class="h3">
                            UserDetailsService
                        </p>

                        <p>
                            Damit Spring Security die Benutzer findet, muss ein UserDetailsService existieren.
                            <br/>
                            Dazu wird im package <code>de.unibielefeld.techfak.tdpe.thymeleaf.domain</code> die neue Klasse 
                            <code>BlogUserDetailsService</code> erstellt, welche das Interface 
                            <code>UserDetailsService</code> implementiert: <!-- Klarstellen: UDS ist ein Spring-Interface! -->
                        </p>


                        <pre>
<code class="java">import de.unibielefeld.techfak.tdpe.thymeleaf.persistence.UserEntity;
import de.unibielefeld.techfak.tdpe.thymeleaf.persistence.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class BlogUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Autowired
    public BlogUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        UserEntity userEntity = userRepository.findOne(username);
        if (userEntity == null) {
            throw new UsernameNotFoundException("User name " + username + " not found.");
        }
        return new User(userEntity.getUsername(),
                userEntity.getFirstName(),
                userEntity.getLastName(),
                userEntity.getPasswordHash(),
                userEntity.getUserRole());
    }
}</code></pre>


                        <hr/>


                        <p class="h3">
                            SecurityConfig
                        </p>

                        <p>

                            SecurityConfig muss jetzt noch der UserDetailsService als Quelle für User mitgeteilt werden.
                            <br/>
                            Dazu wird die alte <code>configureGlobal()</code> in <code>SecurityConfig</code> durch folgende zwei Methoden ersetzt:
                            <!-- Import für PasswordEncoder ausqualifizieren - Spring hat *zwei* Klassen mit dem Namen -->
                        </p>

                        <pre><code class="java">    @Autowired
    public void configureGlobal(UserDetailsService userDetailsService,
                                PasswordEncoder passwordEncoder,
                                AuthenticationManagerBuilder auth) throws Exception {
        auth
            .userDetailsService(userDetailsService)
            .passwordEncoder(passwordEncoder);
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
</code></pre>
                        <p> Durch einen Bug in IntelliJ kann es vorkommen, dass an dieser Stelle behauptet wird, der <code>UserDetailsService</code> könnte
                            nicht <span class="code-java">@Autowired</span> werden. Lasst euch davon nicht irritieren! 
                        </p>
                        <p>
                            Durch die <span class="code-java">@Autowired</span> Annotation an configureGlobal weiß Spring, dass die Parameter mit woanders
                            erzeugten
                            Beans belegt werden müssen.
                            <br/>
                            In <code>configureGlobal()</code> wird dann einfach nur der AuthenticationManagerBuilder darüber informiert, dass es
                            einen
                            <code>UserDetailsService</code> (der eben imlementiert und mit der <span class="code-java">@Service</span> Annotation bereitgestellt wurde)
                            und einen PasswordEncoder verwenden soll. Letzterer kümmert sich darum, die vor einiger Zeit erwähnte
                            Hashfunktion und die dadurch etwas veränderten Passwortvergleiche umzusetzen.</p>

                        <p>Die Methode passwordEncoder() erstellt dann einen neuen PasswordEncoder, der BCrypt als Hashfunktion
                            verwendet. Das ist ein recht aktuelles und momentan als sicher geltendes Hashverfahren. <br/>
                            Durch die <span class="code-java">@Bean</span>-Annotation wird der Rückgabewert der Methode für Autowiring an anderen Stellen verfügbar
                            gemacht, z.B. damit Spring es als Parameter für <code>configureGlobal()</code> benutzen kann.</p>


                        <hr/>


                        <p class="h3">
                            Beispieldaten
                        </p>

                        <p>

                            Damit sich Nutzer einloggen können, müssen diese nun nur noch in der Datenbank vorhanden sein. 
                            Dazu wird in der <code>data.sql</code> folgenes ergänzt: 
                        </p>

                        <pre><code class="sql">INSERT INTO users (username, password_hash, first_name, last_name, user_role) VALUES ('peter', '$2a$10$WoG5Z4YN9Z37EWyNCkltyeFr6PtrSXSLMeFWOeDUwcanht5CIJgPa', 'Peter', 'Parker', 'USER');
INSERT INTO users (username, password_hash, first_name, last_name, user_role) VALUES ('bob', '$2a$10$WoG5Z4YN9Z37EWyNCkltyeFr6PtrSXSLMeFWOeDUwcanht5CIJgPa', 'Bob', 'Page', 'USER');
</code></pre>

                        <p>
                            Die etwas kryptischen Texte im password_hash Feld beider Benutzer sind ein möglicher BCrypt Hash für den Text
                            "password". Wenn andere Passwörter verwendet werden sollnen, kannst man z.B. unter 
                            <a target="_blank" href="http://bcrypthashgenerator.apphb.com/">http://bcrypthashgenerator.apphb.com/</a>
                            ein Passwort eingeben und einen entsprechenden Hash erhalten.
                        </p>

                        <hr/>


                        <p class="h3">
                            Ausprobieren
                        </p>

                        <p>
                            Startet man die Anwendung nun wieder, kann man sich mit den beiden in der Datenbank hinterlegten Nutzern einloggen. 
                        </p>

                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>

                <!--Schritt 13 - Autoren-->
                <div id="authors">
                    <div class="well">
                        <h2>Schritt 13 - Autor in Blogeinträgen hinterlegen</h2>

                        <p>
                            Da nur angemeldete Nutzer neue BlogPosts erstellen können, macht es Sinn, auch in jedem Eintrag 
                            zu hinterlegen, welcher Nutzer ihn erstellt hat.
                        </p>

                        <hr/>

                        <p class="h3">
                            Domänenmodell
                        </p>

                        <p>
                            Die Klasse <code>BlogPost</code> wird dazu folgendermaßen angepasst:
                        </p>

                        <pre>
<code class="java">public class BlogPost {
    private final String id;
    private final User author;
    private final String title;
    private final String text;

    public BlogPost(String id, User author, String title, String text) {
        this.id = id;
        this.author = author;
        this.title = title;
        this.text = text;
    }

    //Getter für alle Felder bitte hier hin!
}
</code></pre>

                        <p>
                            In jedem BlogPost ist somit ein Nutzer hinterlegt.
                        </p>

                        <hr/>

                        <p class="h3">
                            Persistenzmodell
                        </p>

                        <p>
                            Damit die Änderung auch in der Datenbank Anwendung findet, wird die Klasse 
                            <code>BlogPostEntity</code> angepasst und folgendes Feld sowie entsprechende Getter und Setter hinzugefügt:
                        </p>

                        <pre>
<code class="java">    @ManyToOne
    private UserEntity author;
</code></pre>

                        <p>
                            Außerdem wird der Konstruktor angepasst:
                        </p>

                        <pre><code class="java">public BlogPostEntity(UserEntity author, String title, String text) {
    this.title = title;
    this.author = author;
    this.text = text;
}
</code></pre>

                        <p>Die <span class="code-java">@ManyToOne</span>-Annotation gibt hierbei an, dass hier nicht eine vollständige
                            UserEntity in einer Spalte gespeichert werden soll, sondern nur ein Verweis auf eine
                            in der entsprechenden Tabelle gespeicherte UserEntity. <br/>
                            Dieser Verweis wird in der Datenbank als Foreign Key-Spalte modelliert. Die Benennung dieser Spalte basiert
                            auf
                            dem Namen des Felds in BlogPostEntity sowie dem Namen des <span class="code-java">@Id</span>-Felds in
                            UserEntity. <br/>
                            In unserem Beispiel ergibt sich damit eine Spalte "author_username", die auf die "username"-Spalte der
                            Tabelle
                            "users" verweist.</p>


                        <hr/>

                        <p class="h3">
                            Beispieldaten
                        </p>

                        <p>
                            Damit in den Beispieldaten auch entsprechende Einträge vorhanden sind, wird die <code>data.sql</code> angepasst:
                        </p>

                        <pre>
<code class="sql">INSERT INTO users (username, password_hash, first_name, last_name, user_role) VALUES ('peter', '$2a$10$WoG5Z4YN9Z37EWyNCkltyeFr6PtrSXSLMeFWOeDUwcanht5CIJgPa', 'Peter', 'Parker', 'USER');
INSERT INTO users (username, password_hash, first_name, last_name, user_role) VALUES ('bob', '$2a$10$WoG5Z4YN9Z37EWyNCkltyeFr6PtrSXSLMeFWOeDUwcanht5CIJgPa', 'Bob', 'Page', 'USER');
INSERT INTO blog_posts (id, author_username, title, text) VALUES (1, 'bob', 'mein erster eintrag', 'lorem ipsum dolor sit amet...');
INSERT INTO blog_posts (id, author_username, title, text) VALUES (2, 'peter', 'mein zweiter eintrag', 'Wants pawn term, dare worsted ladle gull hoe lift wetter murder inner ladle cordage, honor itch offer lodge dock florist. ');
</code></pre>


                        <hr/>

                        <p class="h3">
                            Service
                        </p>

                        <p>
                            Die Implementation von BlogService muss auch entsprechend angepasst werden.
                            <br/> 
                            Dafür muss BlogServiceImpl erstmal das UserRepository und den UserDetailsService kennen, dazu werden Instanzvariablen und Konstruktor angepasst:
                        </p>

                        <pre><code class="java">    private final BlogPostRepository blogPostRepository;
    private final UserRepository userRepository;
    private final UserDetailsService userDetailsService;

    @Autowired
    public BlogServiceImpl(BlogPostRepository blogPostRepository, UserRepository userRepository, UserDetailsService userDetailsService) {
        this.blogPostRepository = blogPostRepository;
        this.userRepository = userRepository;
        this.userDetailsService = userDetailsService;
    }</code></pre>

                        <p>
                            Außerdem wird die Methode <code>getAllPosts()</code> angepasst:
                        </p>

                        <pre><code class="java">    @Override
    public List&lt;BlogPost&gt; getAllPosts() {
        List&lt;BlogPost&gt; result = new LinkedList&lt;BlogPost&gt;();
        for (BlogPostEntity blogPostEntity : blogPostRepository.findAll()) {
            result.add(new BlogPost(
                    blogPostEntity.getId().toString(),
                    (User) userDetailsService.loadUserByUsername(blogPostEntity.getAuthor().getUsername()),
                    blogPostEntity.getTitle(),
                    blogPostEntity.getText()
            ));
        }
        return result;
    }</code></pre>

                        <p>
                            Die Methode befragt nun also den UserDetailsService (der von einem Benutzernamen auf ein Domänenobjekt User
                            abbilden kann) nach dem korrekten
                            User für die in der Datenbank als Autor hinterlegte UserEntity.
                        </p>

                        <p>
                            <!-- Sauberer formulieren. [In einer groesseren Applikation waere das über interfaces besser regelt. hier nicht. -->
                            Der Cast bei userDetailsService.loadUserByName() ist hier übrigens halbwegs legitim - man weiß, dass der
                            UserDetailsService in dieser Anwendung auch immer nur ein User-Objekt zurück geben kann, darf und muss.
                            <br/>
                            Schöner wäre allerdings gewesen, wenn das UserDetailsService ein eigenes Interface implementieren würde,
                            welches eindeutig sagt dass ein User-Objekt
                            zurück geliefert wird. Dann hätten man dieses Interface statt des allgemeinen UserDetailsService in den
                            BlogService injecten lassen können und bräuchten hier keinen Cast.
                            <br/>
                            Entsprechendes Refactoring ist hier dem motivierten Leser als Übung überlassen.
                        </p>



                        <p>
                            Zusätzlich wird die Methode <code>createBlogPost()</code> geändert, damit diese den Nutzer auch speichert:
                        </p>

                        <pre><code class="java">@Override
public BlogPost createBlogPost(BlogPost blogPost) {
    UserEntity userEntity = userRepository.findOne(blogPost.getAuthor().getUsername());
     
    BlogPostEntity blogPostEntity = new BlogPostEntity(userEntity,blogPost.getTitle(), blogPost.getText());
        
    BlogPostEntity savedEntity = blogPostRepository.save(blogPostEntity);
      
    BlogPost saved = new BlogPost(savedEntity.getId().toString(),
            (User) userDetailsService.loadUserByUsername(savedEntity.getAuthor().getUsername()),
            savedEntity.getTitle(),
            savedEntity.getText());
    
    return saved;
}</code></pre>
                        <p>
                            Diese läd für den im <code>BlogPost</code> hinterlegten <code>User</code> die <code>UserEntity</code>, und fügt diese vor dem Speichern der <code>BlogPostEntity</code> hinzu.
                        </p>


                        <p class="h3">
                            Controller
                        </p>

                        <p>
                            Damit in den zu speichernden BlogPosts auch der aktuelle Nutzer hinterlegt ist, muss der <code>BlogController</code> angepasst werden.
                            <br/>
                            Dazu wird die Methode <code>saveNewPost()</code> angepasst:
                        </p>
                        <pre><code class="java">    @RequestMapping(value = "/new", method = RequestMethod.POST)
    public String saveNewPost(NewBlogPostCmd newBlogPostCmd, @AuthenticationPrincipal User currentUser) {
        BlogPost blogPost = new BlogPost(null, currentUser, newBlogPostCmd.getTitle(), newBlogPostCmd.getText());
        blogService.createBlogPost(blogPost);
        return "redirect:/";
    }</code></pre>

                        <p>Dadurch, dass der Parameter currentUser als <span class="code-java">@AuthenticationPrincipal</span> annotiert ist, weiß Spring, dass
                            nicht irgendeinen Requestparameter gesucht ist, oder einen User in dieser Methode bearbeiten werden soll, 
                            sondern wirklich der momentan eingeloggten User gebraucht wird.
                            <br/>
                            Mehr ist dafür nicht nötig!</p>


                        <p class="h3">
                            View
                            <!-- Genauer beschreiben wo die Anpassung stattfindet!-->
                        </p>

                        <p>
                            Damit die Autoren auch in der View zu sehen sind, muss <code>index.html</code> angepasst werden. 
                            Dazu wird die Überschrift der BlogPosts folgendermaßen geändert:
                        </p>

                        <pre><code class="html">&lt;h2 th:text="${post.title} + ' (von ' + ${post.author.fullName} + ')'"/&gt;</code> </pre>



                        <p class="h3">
                            Ausprobieren
                        </p>

                        <p>
                            Startet man die Anwendung nun wieder, ist bei jedem BlogEintrag der Nutzer hinterlegt.
                        </p>

                        <div class="row">
                            <div class="col-sm-8 col-sm-offset-2">
                                <img src="img/schritt_13.png" alt="Schritt_13" class="center-block img-responsive"/> 
                            </div>
                        </div>

                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>

                <!--Schritt 14 - Datenbank zwischen Programmstarts beibehalten-->
                <div id="db3">
                    <div class="well">
                        <h2>Schritt 14 - Datenbank zwischen Programmstarts beibehalten</h2>

                        <p>
                            Bisher wird H2 als reine in-memory-Datenbank verwendet. Das führt dazu, dass bei jedem Programmstart
                            eine
                            komplett neue Datenbank erstellt wird und evtl. bereits
                            vorhandene Daten verloren gehen.
                            <br/>
                            In diesem Schritt wird die nötige Konfiguration durchgeführt, um
                            die Datenbank statt dessen in einer Datei unterzubringen, sodass
                            die Inhalte zwischen Programmstarts erhalten bleiben.
                        </p>

                        <h3>application.properties</h3>

                        <p>
                            Die <code>application.properties</code> Datei muss um folgenede Zeilen ergänzt werden:
                        </p>

                        <pre>
spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:h2:file:./data/blog.h2db
spring.datasource.driver-class-name=org.h2.Driver
                        </pre>

                        <p>
                            Die erste Zeile sorgt dafür, dass die Tabellen für die Anwendung nur dann erstellt werden sollen, falls
                            sie in
                            der Datenbank nicht zum aktuellen Schema der Anwendung passen.
                            <br/>
                            Die zweite Zeile weist Spring Data an, als Datenbank eine H2-Verbindung zu verwenden, die auf eine
                            Datenbank
                            mit dem namen "blog.h2db" im Verzeichnis data zugreift.
                            <br/>
                            Die dritte Zeile benennt die Klasse, mit der die vorher beschriebe Datenbank geöffnet werden kann.
                        </p>

                        <h3> Interface BlogUserDetailsService anpassen </h3>
                        <p>
                            Im Folgenden werden wir die Datenbankinitialisierung etwas sauberer realisieren. Leider ist dafür einige Arbeit nötig. <br/>
                            Als erstes ändert den Namen von <code>BlogUserDetailsService</code> auf <code>BlogUserDetailsServiceImpl</code> mittels
                            Refactoring. <br/>
                            Erstellt dann ein neues Interface mit dem Namen <code>BlogUserDetailsService</code> (unterhalb des domain Pakets), 
                            der ja nun wieder frei ist.</p>
                        <pre><code class="java">import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;


public interface BlogUserDetailsService extends UserDetailsService {

    User loadUserByUsername(String s) throws UsernameNotFoundException;
    void addUser(User user);
}</code></pre>
                        <p>Nun kann auch <code>BlogUserDetailsServiceImpl</code> unser neues Interface implementieren: </p>

                        <pre><code class="java">@Service
public class BlogUserDetailsServiceImpl implements BlogUserDetailsService {</code></pre>

                        <p>Zusätzlich muss ein Feld für den PasswortEncoder hinzugefügt werden und der Konstruktor angepasst werden</p>
                        <pre><code> private final UserRepository userRepository;
private final PasswordEncoder passwordEncoder;
  
@Autowired
public BlogUserDetailsService(UserRepository userRepository,PasswordEncoder passwordEncoder) {
    this.userRepository = userRepository;
    this.passwordEncoder=passwordEncoder;
}</code></pre>

                        <p>Ausserdem kann nun die loadUserByUsername()-Methode nun einen User zurückliefern und eine addUser()-Methode,
                            die wir gleich brauchen werden, kann hinzugefügt werden. </p>

                        <pre><code class="java">    @Override
    public User loadUserByUsername(String username) throws UsernameNotFoundException {
        UserEntity userEntity = userRepository.findOne(username);
        if (userEntity == null) {
            throw new UsernameNotFoundException("User name " + username + " not found.");
        }
        return new User(userEntity.getUsername(),
                userEntity.getFirstName(),
                userEntity.getLastName(),
                userEntity.getPasswordHash(),
                userEntity.getUserRole());
    }

    @Override
    public void addUser(User user) {
        UserEntity userEntity = new UserEntity();
        userEntity.setFirstName(user.getFirstName());
        userEntity.setLastName(user.getLastName());
        userEntity.setUsername(user.getUsername());
        userEntity.setUserRole("USER");
        userEntity.setPasswordHash(passwordEncoder.encode(user.getPassword()));
        userRepository.save(userEntity);
    }</code></pre>


                        <p>Die Klasse BlogPostImpl kann nun so angepasst werden, dass der neue <code>BlogUserDetailsService</code> anstatt des <code>UserDetailsService</code> genutzt werden kann:</p>

                        <pre><code>private final BlogPostRepository blogPostRepository;
private final UserRepository userRepository;
private final BlogUserDetailsService blogUserDetailsService;

@Autowired
public BlogServiceImpl(BlogPostRepository blogPostRepository, UserRepository userRepository, BlogUserDetailsService blogUserDetailsService) {
    this.blogPostRepository = blogPostRepository;
    this.userRepository = userRepository;
    this.blogUserDetailsService = blogUserDetailsService;
}</code></pre>

                        <p>Aus der Methode getAllPosts() in der Klasse <code>BlogServiceImpl</code> kann nun auch der etwas problematische cast entfernt werden,
                            so dass sie nun wie folgt aussehen sollte: </p>
                        <pre><code class="java">    @Override
    public List getAllPosts() {
        List&lt;BlogPost&gt; result = new LinkedList&lt;BlogPost&gt;();
        for (BlogPostEntity blogPostEntity : blogPostRepository.findAll()) {
            result.add(new BlogPost(
                    blogPostEntity.getId().toString(),
                    blogUserDetailsService.loadUserByUsername(blogPostEntity.getAuthor().getUsername()),
                    blogPostEntity.getTitle(),
                    blogPostEntity.getText()
            ));
        }
        return result;
    }</code></pre>
                        <h3>Initializierung der Datenbank anpassen</h3>
                        <p>Nach den Vorarbeiten können wir nun die Initialisierung der Datenbank aus der Datei <code>data.sql</code> entfernen
                            und diese stattdessen in einer Initialisierungsklassen durchführen. Das Problem mit der Initialisierung mittels
                            SQL Scripten ist nämlich, dass diese zu einem sehr frühen Zeitpunkt ausgeführt werden, an dem im Datenbanksystem 
                            noch kein Transaktionsmanagement aktiv ist. Das Transaktionsmanagement verhindert unter anderem das Erzeugen von
                            inkonsistenten Zuständen der Datenbank. Das könnte bei einem Script noch passieren, wenn zum Beispiel beim Ausführen
                            des Scripts etwas schief geht. <br/>
                            Wir erzeugen nun in dem <code>domain</code> Paket eine neue Klasse <code>InitializeDatabase</code> mit folgendem Inhalt:
                        </p>
                        <pre><code class="java">import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class InitializeDatabase implements InitializingBean {

    private final BlogUserDetailsService userDetailsService;
    private final BlogService blogService;

    @Autowired
    public InitializeDatabase(BlogUserDetailsService userDetailsService, BlogService blogService) {
        this.userDetailsService = userDetailsService;
        this.blogService = blogService;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        try {
            userDetailsService.loadUserByUsername("bob");
        } catch (UsernameNotFoundException enfe) {
            userDetailsService.addUser(new User("bob", "Bob", "Page", "password", "User"));
        }
        try {
            userDetailsService.loadUserByUsername("peter");
        } catch (UsernameNotFoundException enfe) {
            userDetailsService.addUser(new User("peter", "Peter", "Parker", "password", "User"));
        }
        if (blogService.getAllPosts().isEmpty()) {
            blogService.createBlogPost(new BlogPost(null, userDetailsService.loadUserByUsername("bob"),
                    "mein erster eintrag", "lorem ipsum dolor sit amet..."));
            blogService.createBlogPost(new BlogPost(null, userDetailsService.loadUserByUsername("peter"),
                    "mein zweiter eintrag", "Wants pawn term, dare worsted ladle gull hoe lift wetter" +
                    " murder inner ladle cordage, honor itch offer lodge dock florist."));
        }
    }
}</code></pre>
                        <p>Wir nutzen hier aus, dass die Methode afterPropertiesSet() einer InitializingBean zu einem frühen Zeitpunkt
                            der Anwendung ausgeführt wird. Geprüft wird hier nur, ob die beiden Standardbenutzer und BlogPosts vorhanden
                            sind und erstellen diese ggf. neu.
                        </p>

                        <h3>data.sql </h3>

                        <p>
                            Diese Datei wird nicht weiter benötigt und <b>muss gelöscht</b> werden! 
                        </p>

                        <hr>

                        <h3>Ausprobieren!</h3>


                        <p>
                            Starte das Programm mit mvn spring-boot:run und füge einen neuen Blogeintrag hinzu. Beende danach die Anwendung
                            und starte sie neu. Der Blogeintrag ist weiterhin da!
                        </p>
                    </div>
                    <hr>
                </div>

                <!--Schritt 15 - Form Validation-->
                <div id="validation">
                    <div class="well">
                        <h2>Schritt 15 - Form Validation</h2>

                        <p>Momentan ist es möglich, das Formular zum Erstellen eines neuen Blogeintrags leer abzusenden. Im diesem Fall
                            wird
                            auch
                            tatsächlich ein leerer Eintrag erstellt und taucht danach auf der Startseite auf.</p>

                        <p>Schöner wäre es natürlich, wenn der Autor darauf hingewiesen würde dass alle Formularfelder ausgefüllt sein
                            müssen und
                            ein unvollständig ausgefülltes Formular niemals in der Datenbank landen kann.</p>

                        <p>Hierfür wird Bean Validation verwendet. Dabei handelt es sich um einen Java EE-Standard, der z.B. vom
                            Hibernate-Projekt implementiert wird.</p>

                        <h3>Abhängigkeiten</h3>

                        <p>Zunächst muss eine Bean Validation Implementation den Abhängigkeiten in der pom.xml hinzugefügt werden</p>
                        <pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
    &lt;version&gt;5.1.3.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

                        <h3>Controller</h3>

                        <p>
                            Um Form Validation zu nutzen, kann man Annotationen in unserer Klasse "NewBlogPostCmd" im Paket 
                            <code>de.unibielefeld.techfak.tdpe.thymeleaf</code> einfügen:
                        </p>
                        <pre><code class="java">public  class NewBlogPostCmd {
    @NotBlank
    private String title;
    
    @NotBlank
    private String text;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }
}
</code></pre>
                        <p>
                            Unsere privaten Felder sind werden mit Annotationen versehen, die
                            angeben welche Eigenschaften der Eingabe erfüllt sein müssen, damit das jeweilige Feld als 
                            'korrekt ausgefüllt' gelten kann.
                        </p>

                        <p>
                            Die hier verwendete <span class="code-java">@NotBlank</span>-Annotation gibt an, dass das Feld ausgefüllt
                            sein
                            muss.
                            <br/>
                            Es existieren noch viele weitere, wie z.B. <span class="code-java">@Past</span>, was vorsieht dass ein
                            eingegebenes Datum in der Vergangenheit liegen muss
                            oder <span class="code-java">@CreditCardNumber</span> um anzugeben dass 
                            eine Eingabe der Form einer Kreditkartennummer entsprechen soll.
                        </p>

                        <p>Außerdem müssen die beiden Methoden, die sich mit dem erstellen neuer Posts befassen, wie folgt angepasst werden:</p>
                        <pre><code class="java">@Controller
public class BlogController {
    // ...stuff ...
    
    @RequestMapping(value = "/new", method = RequestMethod.POST)
    public String saveNewPost(@Valid NewBlogPostCmd newBlogPostCmd,
                              BindingResult bindingResult,
                              Model model,
                              @AuthenticationPrincipal User currentUser) {
        if (bindingResult.hasErrors()) {
            model.addAttribute("newBlogPostCmd", newBlogPostCmd);
            return "newPostForm";
        } else {
            BlogPost blogPost = new BlogPost(null, currentUser, newBlogPostCmd.getTitle(), newBlogPostCmd.getText());
            blogService.createBlogPost(blogPost);
            return "redirect:/";
        }
    }
    //... stuff...
}</code></pre>

                        <p>
                            Der Parameter newBlogPostCmd ist nun mit <span class="code-java">@Valid</span> annotiert, um Spring darüber 
                            zu informieren, dass die in NewBlogPostCmd hinterlegten Validierungen vor Aufruf von saveNewPost() durchgeführt 
                            werden müssen. Der unmittelbar darauf folgende BindingResult Parameter enthält die Ergebnisse der Validierung 
                            - also, welche Felder Fehler enthalten, und was für Fehlermeldungen auszugeben sind.
                        </p>

                        <p>
                            Innerhalb der Methode müssen nun zwei verschiedene Fälle behandelt werden: <br/>
                            Ist das Formular noch nicht korrekt ausgefüllt, soll es noch einmal angezeigt werden. 
                            Die View soll dann das bereits existierende NewBlogPostCmd verwenden um die Benutzereingaben 
                            im Formular als Vorbelegungen für alle Felder einzutragen. 
                            <br/>
                            Ist das Formular nicht fehlerhaft, soll statt dessen wie früher ein neuer Blogeintrag 
                            gespeichert und der Benutzer auf die Startseite weitergeleitet werden.
                        </p>

                        <hr/>
                        <h3>
                            View
                        </h3>

                        <p>In der View für das zu validierende Formular müssen nun noch ggf. anfallende Fehlermeldungen angezeigt werden.

                        <p>
                            Das Formular in <code>newPostForm.html</code> wird dazu folgendermaßen angepasst:
                        </p>

                        <pre><code class="html">&lt;!DOCTYPE html&gt;

&lt;html xmlns:th="http://www.thymeleaf.org"&gt;

&lt;body&gt;
&lt;form action="#" th:action="@{/new}" th:object="${newBlogPostCmd}" method="post"&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label for="title"&gt;Titel:&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type="text" id="title" name="title" th:field="*{title}"/&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('title')}" th:errors="*{title}"&gt;Darf nicht leer sein!&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label for="text"&gt;Text:&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;textarea id="text" name="text" th:field="*{text}"&gt;&lt;/textarea&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('text')}" th:errors="*{text}"&gt;Darf nicht leer sein!&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;input type="submit" id="submit" value="Speichern"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;

&lt;form th:action="@{/logout}" method="post"&gt;
    &lt;input type="submit" value="Logout"/&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
                        <p>
                            Gehen wir das neue Formular schrittweise durch:
                        </p>

                        <ul>
                            <li>
                                <p>
                                    Wir benutzen nun eine HTML-Tabelle, um das Formular etwas übersichtlicher und Fehlermeldungen an der richtigen Stelle
                                    anzeigen zu können.
                                </p>
                            </li>
                            <li>
                                <p>
                                    Wir haben nun neue 
                                    <span class="code-html">&lt;td th:if="${#fields.hasErrors('title')}" th:errors="*{title}"&gt;</span>-Tags.
                                    Diese werden nur bei Fehlern im angegebenen Feld angezeigt.

                                </p>
                            </li>

                        </ul>
                        <hr/>
                        <h3>
                            Ausprobieren
                        </h3>

                        <p>
                            Tätigt man nun fehlerhafte Eingaben, erhält man Fehlermeldungen und es wird kein neuer BlogPost erstellt:
                        </p>

                        <div class="row">
                            <div class="col-sm-6 col-sm-offset-3">
                                <img src="img/schritt_15.png" alt="Schritt_15" class="center-block img-responsive"/> 
                            </div>
                        </div>

                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>


                <!--Schritt 16 - Nach Autor suchen-->
                <div id="search">
                    <div class="well">
                        <h2>Schritt 16 - Nach Autor suchen</h2>

                        <p>
                            Bisher werden auf der Startseite alle Einträge von allen Autoren angezeigt.
                            <br>
                            Eine einfache Erweiterung des Blogs wäre die Möglichkeit, nach Autoren zu suchen, und nur Einträge eines Autors zu zeigen.
                        </p>

                        <p>Für das filtern der Beiträge nach Autoren innerhalb der Anwendung gibt es zwei Möglichkeiten:</p>

                        <ul>
                            <li>
                                Aus der Datenbank nur die BlogPosts für einen Autor abfragen.
                                <br>
                                Dies führt zu mehr Logik in der Datenbankschicht (hier Repository und Service), hält aber die Controller klein.
                                Bei komplexeren Suchparametern führt dies aber sehr schnell zu einer sehr aufgeblähten und komplexen Datenbankschicht, 
                                weshalb dies eher bei einfacheren Filtern empfohlen sei.
                            </li>


                            <li>
                                Aus der Datenbank alle BlogPosts laden, und innerhalb des Controllers nach Autoren filtern.
                                <br>
                                Dies führt zu mehr Logik im Controller, die Datenbankschicht muss aber nicht verändert werden, und bleibt einfach und kompakt.
                                Außerdem lassen sich komplexere Filter so oftmals schneller uns einfacher realisieren.
                            </li>
                        </ul>

                        <p>
                            Nachfolgend werden beide Möglichkeiten an zwei Beispielen implementiert.
                            <br>
                            Eine Suche nach Autoren wird mithilfe von Filtern im Controller realisiert, und Auswahl von 
                            Autoren aus einer Liste mit Filtern in der Datenbankschicht.
                        </p>

                        <hr>
                        <h3>Repository</h3>

                        <p>Zunächst passen wir dazu das BlogPostRepository an, um nur BlogPosts für einen bestimmten Autor zu erhalten. 
                            Dazu wird dem Repository folgende Methodendeklaration hinzugefügt:</p>
                        <pre><code class="java">List&lt;BlogPostEntity&gt; findByAuthor(UserEntity author);</code></pre>

                        <p>
                            Spring generiert dabei anhand des Methodennamens für die Datenbank die passenden Querys, 
                            ohne das der Programmierer diese selbst schreiben muss. Eine Liste von
                            <!-- Link ist tot!-->
                            <a target="_blank" href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods">Möglichkeiten findet man 
                                hier.</a>
                        </p>
                        <p>
                            Durch den Rückgabetyp <code class="java">List&lt;BlogPostEntity&gt;</code> weiß Spring dabei, 
                            das eine Liste von BlogPosts gesucht werden soll, wäre er <code class="java">BlogPostEntity</code>, 
                            würde jeweils nur der erste Beitrag zurückgegeben werden.
                        </p>
                        <p>
                            Anhand des Methodennamens wird dann bestimmt, wonach gesucht werden soll, in diesem Fall alle 
                            für einen bestimmten Autor, der als Parameter übergeben wird.
                            <br>
                            Autor ist dabei der Name des Feldes innerhalb von BlogPostEntity, welches vom Typ User ist.
                        </p>

                        <hr>
                        <h3>Service</h3>

                        <p>
                            Damit es später in der Anwendung auch möglich ist, BlogPosts für einen User zu laden, muss dafür das Interface <code>BlogService</code> eine Möglichkeit bieten.
                            Dazu wird dieses um die Methode <code>List&lt;BlogPost&gt; getAll(User user)</code> erweitert.
                        </p>

                        <p>
                            Diese Methode implementiert <code>BlogServiceImpl</code>:
                        </p>
                        <pre><code class="java">    @Override
    public List&lt;BlogPost&gt; getAll(User user) {
    UserEntity userEntity = userRepository.findOne(user.getUsername());
        
        List&lt;BlogPost&gt; result = new LinkedList&lt;BlogPost&gt;();
        for (BlogPostEntity blogPostEntity : blogPostRepository.findByAuthor(userEntity)) {
            result.add(new BlogPost(
                    blogPostEntity.getId().toString(),
                    userDetailsService.loadUserByUsername(blogPostEntity.getAuthor().getUsername()),
                    blogPostEntity.getTitle(),
                    blogPostEntity.getText()
            ));
        }
        return result;
    }
</code></pre>

                        <p>
                            Um eine Liste aller Nutzer anzeigen zu können, wird außerdem ein Interface für einen 
                            UserService benötigt, welches eine Methode zum Laden aller Nutzer bereitstellt.
                            <br>
                            Dazu wird das neue Interface <code>BlogUserDetailsService</code> im Package <code>de.unibielefeld.techfak.tdpe.thymeleaf.domain</code> erweitert:
                        </p>

                        <pre><code class="java">public interface BlogUserDetailsService extends UserDetailsService {
    User loadUserByUsername(String s) throws UsernameNotFoundException;
    void addUser(User user);
    List&lt;User&gt; getAll();
    User getOne(String username);
}</code></pre>

                        <p>
                            Die neuen Methoden werden nun in <code>BlogUserDetailsServiceImpl</code>  implementiert:
                        </p>

                        <pre><code class="jave">@Override
public List&lt;User&gt; getAll() {
    List&lt;User&gt; users = new LinkedList&lt;&gt;();
     
    for (UserEntity userEntity : userRepository.findAll()) {
        users.add(new User(userEntity.getUsername(),
            userEntity.getFirstName(),
            userEntity.getLastName(),
            userEntity.getPasswordHash(),
            userEntity.getUserRole())
        );
    }
       
    return users;
}

@Override
public User getOne(String username) {
    return (User) loadUserByUsername(username);
}
</code></pre>

                        <hr>
                        <h3>Controller</h3>


                        <p>
                            Damit eine Liste aller Autoren angezeigt werden kann, aus der der Nutzer dann einen bestimmten 
                            auswählen kann, werden die Instanzvariablen und der Konstruktor von <code>BlogController</code> 
                            um den eben erstellten Service erweitert.
                        </p>

                        <pre><code class="java">public class BlogController {
    private final BlogService blogService;
    private final BlogUserDetailsService blogUserDetailsService;

    @Autowired
    public BlogController(BlogService blogService, BlogUserDetailsService blogUserDetailsService) {
        this.blogService = blogService;
        this.blogUserDetailsService = blogUserDetailsService;
    }

    //stuff

}
</code></pre>

                        <p>
                            Außerdem wird die <code>index()</code>-Methode erweitert, damit sie der View eine Liste 
                            aller Autoren bereitstellt: 
                        </p>

                        <pre><code class="java">@RequestMapping("/")
public String index(Model model) {
    model.addAttribute("blogPosts", this.getBlogPosts());
    model.addAttribute("authors", blogUserDetailsService.getAll());
    return "index";
}
</code></pre>

                        <p>
                            Um der View die entsprechenden Daten bereitzustellen, werden zusätzlich noch zwei Methoden implementiert.
                        </p>

                        <p>
                            Einmal die Methode, um die Einträge für einen ausgewählten Nutzer anzuzeigen:
                        </p>

                        <pre><code class="java">@RequestMapping(value = "/byusername")
public String showbyUsername(@RequestParam(value = "username") String username, Model model) {
    User user = blogUserDetailsService.getOne(username);

    List&lt;BlogPost&gt; blogPosts = blogService.getAll(user);
    model.addAttribute("blogPosts", blogPosts);
    model.addAttribute("authors", blogUserDetailsService.getAll());
    return "index";
}
</code></pre>

                        <p>
                            Sowie die Methode zur Freitextsuche:
                        </p>

                        <pre><code class="java">@RequestMapping(value = "/search")
public String search(@RequestParam(value = "search_query") String searchQuery, Model model) {

    List&lt;BlogPost&gt; searched = getBlogPosts().stream()
            .filter(blogPost
                    -> blogPost.getAuthor().getFullName().contains(searchQuery)
                    || blogPost.getAuthor().getUsername().contains(searchQuery))
            .collect(Collectors.toList());


    model.addAttribute("blogPosts", searched);
    model.addAttribute("authors", blogUserDetailsService.getAll());
    return "index";
}
</code></pre>

                        <p>
                            Diese Methode verwendet die mit Java 8 hinzugekommenen <code>Streams</code>, um aus der 
                            Liste aller BlogPosts die zu filtern, bei denen entweder der volle Name des Autors oder sein 
                            UserName den Suchstring enthält.
                            <br/>
                            Die Funktion, nach der gefiltert wird, ist hierbei mit <i>Lambda Expressions</i> realisiert, 
                            ließe sich jedoch gleichermaßen mit einer Instanz des Interfaces <code>Predicate</code> umsetzten.
                            Dieses kann dabei entweder normal oder als anonyme Klasse implementiert werden.
                        </p>


                        <hr/>

                        <h3>
                            SecurityConfig
                        </h3>

                        <p>
                            Bisher lassen sie Konfigurationen in der <code>SecurityConfig</code> öffentliche 
                            Zugriffe nur auf "/" zu, für die Suche sind aber auch Zugriffe auf "/search" und "/byusername" nötig. 
                            Die Zeile <code>.antMatchers("/").permitAll()</code> wird deshalb 
                            abgeändert zu <code>.antMatchers("/","/search","/byusername").permitAll()</code>
                            <br/>
                            Dadurch sind Zugriffe auf die drei Pfade "/", "search" und "/byusername" für jeden Nutzer möglich.
                        </p>

                        <hr/>

                        <h3>
                            View
                        </h3>

                        <p>
                            Damit der Nutzer nun auch suchen kann, sind noch passende Änderungen an der View nötig. 
                        </p>

                        <p>
                            In der <code>index.html</code> wird dazu zuerst innerhalb des bodys eine neue Form hinzugefügt. 
                            Diese stellt die Suchmaske für das Suchen nach Autoren dar:
                        </p>
                        <pre><code class="html">&lt;form method="get" action="#" th:action="@{/search}"&gt;
    &lt;input name="search_query" placeholder="Suche..."/&gt;
    &lt;button&gt;Suchen&lt;/button&gt;
&lt;/form&gt;
</code></pre>


                        <p>
                            Zusätzlich zu der Form wird noch eine Liste von Autoren hinzugefügt, die auf die jeweiligen Beiträge eines Autors verlinken:
                        </p>
                        <pre><code class="html">&lt;th:block th:each="author:${authors}"&gt;
    &lt;a th:href="@{/byusername(username=${author.username})}" th:text="${author.fullName}"/&gt;
    &lt;br/&gt;
&lt;/th:block&gt;
</code></pre>

                        <p>
                            Dies ist wieder eine forEach-Schleife, die über die im <code>BlogController</code> gefüllte 
                            Liste der Autoren iteriert.
                            Für jeden Autor wird dabei mit <span class="code-html">&lt;a th:href=""&gt;</span> ein Link erstellt. 
                            Dem Link wird dabei als Parameter <code>username</code> der UserName des Autors angehängt.
                        </p>

                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>


                <!--Vorschläge für weitere Schritte-->
                <div id="next">
                    <div class="well">
                        <h2>Vorschläge für weitere Schritte</h2>

                        <h3>Einzelne Blog-Einträge anzeigen</h3>
                        <p>
                            Ein Klick auf die Überschrift eines BlogPosts soll eine Übersicht mit diesem einzelnen Eintrag öffen. 
                        </p>

                        <hr>


                        <h3>Blog-Einträge löschen</h3>
                        <p>
                            Der Autor eines Beitrags soll die Möglichkeit haben, diesen Beitrag zu löschen.
                        </p>

                        <hr>

                        <h3>Blog-Einträge bearbeiten</h3>
                        <p>
                            Der Autor eines Beitrags soll die Möglichkeit haben, diesen Beitrag zu bearbeiten.
                        </p>

                        <hr>

                        <h3>Admins</h3>
                        <p>
                            Admins als neue Nutzerrolle hinzufügen.
                            Diese sollen neue Nutzer erstellen und Beiträge löschen können.
                        </p>



                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>


                <!--Anhang-->
                <div id="links">
                    <div class="well">
                        <h2>interessante Links und weitere Literatur</h2>

                        <dl>
                            <dt><a target="_blank" href="http://spring.io/guides">http://spring.io/guides</a></dt>
                            <dd>Offizielle Spring Tutorials</dd>
                            <br>

                            <dt><a target="_blank" href="http://getbootstrap.com/css/">http://getbootstrap.com/css/</a></dt>
                            <dd>Übersicht über die CSS-Klassen in Bootstrap</dd>
                            <br>

                            <dt><a target="_blank" href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters">
                                https://github.com/spring-projects/spring-boot/tree/master/spring-boot-starters
                            </a>
                            </dt>
                            <dd>Liste der spring-boot-starter Artefakte</dd>
                            <br>



                            <dt><a target="_blank" href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods">
                                http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods
                            </a>
                            </dt>
                            <dd>Spring data JPS Query-Methods</dd>
                            <br>


                            <dt><a target="_blank" href="http://www.mehdi-khalili.com/orm-anti-patterns-series/">
                                http://www.mehdi-khalili.com/orm-anti-patterns-series/
                            </a>
                            </dt>
                            <dd>ORM Anti-Patterns</dd>
                            <br>

                            <dt><a target="_blank" href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">
                                http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api
                            </a>
                            </dt>
                            <dd>
                                Best-Practices für Rest-APIs
                                <br/>
                                Bezieht sich zwar hauptsächlich auf REST und nicht HTML, 
                                die meisten Punkt gelten aber auch für HTML.
                                <br/>
                            </dd>
                            <br>



                            <dt><a target="_blank" href="https://code.google.com/p/guava-libraries/">https://code.google.com/p/guava-libraries/</a></dt>
                            <dd>Eine Bibliothek mit diversen Hilfsmethoden z.B. zum komfortableren Umgang mit Collections in Java</dd>
                            <br>

                            <dt><a target="_blank" href="http://www.webjars.org/">http://www.webjars.org/</a></dt>
                            <dd>Übersicht über die via Webjars als Maven-Artefakte verfügbaren Frontend-Bibliotheken</dd>
                            <br>

                            <dt><a target="_blank" href="http://portswigger.net/burp/proxy.html">Burp Proxy</a></dt>
                            <dd>Tool zum analysieren und verändern von HTTP-Requests. Für einfache Projekte eher selten Wertvoll. Aber
                                wenn,
                                dann unentbehrlich :)
                                <br/>Die vollversion kostet Geld, aber auch die "eingeschränkte" Fassung ist im Allgemeinen vollkommen
                                ausreichend.
                            </dd>
                        </dl>
                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>


                <!--Hinweise-->
                <div id="notes">
                    <div class="well">
                        <h2>weitere Hinweise</h2>

                        <h4>Template Reload</h4>
                        <p>
                            In der normalen Konfiguration muss jedes mal, wenn Thymeleaf-Templates geändert werden, 
                            die Anwendung neu gestartet werden, um diese zu übernehmen.
                            <br>
                            Durch die <code>spring-boot-devtools</code>, welche in der starter-pom eingebunden sind, 
                            ist dies nicht mehr nötig, 
                            es müssen jedoch zusätzlich die Resources extra eingebunden werden.
                            <br>Dazu muss 
                            innerhalb der <code>&lt;build&gt;</code>-Tags folgendes eingefügt werden:



                        </p>
                        <pre><code>
&lt;resources&gt;
    &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
    &lt;/resource&gt;
<&lt;/resources&gt;
</code></pre>

                        <h4>PUT, PATCH & DELETE in HTML</h4>

                        <p>
                            Die http-Methoden PUT,PATCH,DELETE lassen sich in normalem HTML nicht verwenden, 
                            jedoch bietet Spring Boot Möglichkeiten, diese zusätzlich zu GET und POST zu nutzen.
                            <br>
                            Gibt man die <code>form</code>-Methode in Templates nicht mit <code>method</code>, sondern mit 
                            <code>th:method</code> an, wandelt Spring die Methoden in für den Browser passende um, 
                            in der  Anwendung lassen sie sich aber als PUT,PATCH & DELETE verwenden.
                        </p>



                    </div>
                    <div class="toplink" align="right"><a href="#">Start of page <span class="glyphicon glyphicon-menu-up" aria-hidden="true"></span></a></div>
                    <hr>
                </div>



            </div>
        </div>
    </body>
</html>
